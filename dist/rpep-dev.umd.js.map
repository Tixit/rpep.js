{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 040a7bda964bd3d08723","webpack:///./node_modules/eventemitter2/lib/eventemitter2.js","webpack:///./node_modules/proto/proto.js","webpack:///./rpep.js(original)","webpack:///./node_modules/process/browser.js","webpack:///./utils.js(original)","webpack:///./DuplexEventEmitter.js(original)"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;;+CC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,oDAAoD,YAAY;AAChE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,kDAAkD,uBAAuB;AACzE;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;;AAEA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2BAA2B;AAC3B,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,wCAAwC,iCAAiC;AACzE;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,4CAA4C;AAC5C,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;AACA;;AAEA;;AAEA,iDAAiD,YAAY;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AAAA;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;ACvwBD;AACA;;AAEA;;AAEA,kGAAkG,iBAAiB;AACnH;AACA;;AAEA;AACA,sBAAsB;AACtB;;AAEA,KAAK,OAAO;AACZ;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uDAAuD;AACvD;AACA,cAAc;AACd;AACA,KAAK;AACL;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA,+CAA+C;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;AACvC;;AAEA;AACA;;AAEA,0BAA0B;;AAE1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mEAAmE;AA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UAAS,KAAM,WAAS;QAC9B,IAAG,SAAS;YACR,MAAM,IAAI,KAAJ,CAAU,0BAAwB,KAAxB,GAA8B,yBAA9B,GAAwD,KAAxD,GAA8D;QAElF,WAAW,EAAX,CAAc,IAAd,CAAmB,MAAM,OAAM;IACvC;IAEI,KAAK,KAAL,GAAa,UAAS,UAAU;QAC5B,WAAW,KAAX,CAAiB,IAAjB,CAAsB,OAAM,UAAS,WAAW;YAC5C,IAAG,EAAE,aAAa,+BAA+B;gBAC7C,SAAS,KAAT,CAAe,MAAM;YACrC;QACA,EAJoC,CAI1B,IAJ0B,CAIrB;IACf;AACA;AAEA,SAAS,6BAA6B,YAAY;IAC9C,IAAI,0BAA0B,IAAI,qBAAqB,MAAI,UAAJ,GAAe;IACtE,wBAAwB,IAAxB,GAA+B;IAC/B,OAAO;AACX;;AAEA,SAAS,IAAI,IAAM,WAAS;IACxB,IAAI,QAAQ,IAAI,KAAJ,CAAU,WAAW;IACjC,MAAM,IAAN,GAAa;IACb,OAAO;AACX;;AA90BA;;;;;;;;;;;;;;ACAA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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","file":"rpep-dev.umd.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"rpep\"] = factory();\n\telse\n\t\troot[\"rpep\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 040a7bda964bd3d08723","/*!\r\n * EventEmitter2\r\n * https://github.com/hij1nx/EventEmitter2\r\n *\r\n * Copyright (c) 2013 hij1nx\r\n * Licensed under the MIT license.\r\n */\r\n;!function(undefined) {\r\n\r\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\r\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\r\n  };\r\n  var defaultMaxListeners = 10;\r\n\r\n  function init() {\r\n    this._events = {};\r\n    if (this._conf) {\r\n      configure.call(this, this._conf);\r\n    }\r\n  }\r\n\r\n  function configure(conf) {\r\n    if (conf) {\r\n      this._conf = conf;\r\n\r\n      conf.delimiter && (this.delimiter = conf.delimiter);\r\n      this._maxListeners = conf.maxListeners !== undefined ? conf.maxListeners : defaultMaxListeners;\r\n\r\n      conf.wildcard && (this.wildcard = conf.wildcard);\r\n      conf.newListener && (this.newListener = conf.newListener);\r\n      conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);\r\n\r\n      if (this.wildcard) {\r\n        this.listenerTree = {};\r\n      }\r\n    } else {\r\n      this._maxListeners = defaultMaxListeners;\r\n    }\r\n  }\r\n\r\n  function logPossibleMemoryLeak(count, eventName) {\r\n    var errorMsg = '(node) warning: possible EventEmitter memory ' +\r\n        'leak detected. ' + count + ' listeners added. ' +\r\n        'Use emitter.setMaxListeners() to increase limit.';\r\n\r\n    if(this.verboseMemoryLeak){\r\n      errorMsg += ' Event name: ' + eventName + '.';\r\n    }\r\n\r\n    if(typeof process !== 'undefined' && process.emitWarning){\r\n      var e = new Error(errorMsg);\r\n      e.name = 'MaxListenersExceededWarning';\r\n      e.emitter = this;\r\n      e.count = count;\r\n      process.emitWarning(e);\r\n    } else {\r\n      console.error(errorMsg);\r\n\r\n      if (console.trace){\r\n        console.trace();\r\n      }\r\n    }\r\n  }\r\n\r\n  function EventEmitter(conf) {\r\n    this._events = {};\r\n    this.newListener = false;\r\n    this.verboseMemoryLeak = false;\r\n    configure.call(this, conf);\r\n  }\r\n  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property\r\n\r\n  //\r\n  // Attention, function return type now is array, always !\r\n  // It has zero elements if no any matches found and one or more\r\n  // elements (leafs) if there are matches\r\n  //\r\n  function searchListenerTree(handlers, type, tree, i) {\r\n    if (!tree) {\r\n      return [];\r\n    }\r\n    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,\r\n        typeLength = type.length, currentType = type[i], nextType = type[i+1];\r\n    if (i === typeLength && tree._listeners) {\r\n      //\r\n      // If at the end of the event(s) list and the tree has listeners\r\n      // invoke those listeners.\r\n      //\r\n      if (typeof tree._listeners === 'function') {\r\n        handlers && handlers.push(tree._listeners);\r\n        return [tree];\r\n      } else {\r\n        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\r\n          handlers && handlers.push(tree._listeners[leaf]);\r\n        }\r\n        return [tree];\r\n      }\r\n    }\r\n\r\n    if ((currentType === '*' || currentType === '**') || tree[currentType]) {\r\n      //\r\n      // If the event emitted is '*' at this part\r\n      // or there is a concrete match at this patch\r\n      //\r\n      if (currentType === '*') {\r\n        for (branch in tree) {\r\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\r\n            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));\r\n          }\r\n        }\r\n        return listeners;\r\n      } else if(currentType === '**') {\r\n        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));\r\n        if(endReached && tree._listeners) {\r\n          // The next element has a _listeners, add it to the handlers.\r\n          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\r\n        }\r\n\r\n        for (branch in tree) {\r\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\r\n            if(branch === '*' || branch === '**') {\r\n              if(tree[branch]._listeners && !endReached) {\r\n                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\r\n              }\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\r\n            } else if(branch === nextType) {\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));\r\n            } else {\r\n              // No match on this one, shift into the tree but not in the type array.\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\r\n            }\r\n          }\r\n        }\r\n        return listeners;\r\n      }\r\n\r\n      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));\r\n    }\r\n\r\n    xTree = tree['*'];\r\n    if (xTree) {\r\n      //\r\n      // If the listener tree will allow any match for this part,\r\n      // then recursively explore all branches of the tree\r\n      //\r\n      searchListenerTree(handlers, type, xTree, i+1);\r\n    }\r\n\r\n    xxTree = tree['**'];\r\n    if(xxTree) {\r\n      if(i < typeLength) {\r\n        if(xxTree._listeners) {\r\n          // If we have a listener on a '**', it will catch all, so add its handler.\r\n          searchListenerTree(handlers, type, xxTree, typeLength);\r\n        }\r\n\r\n        // Build arrays of matching next branches and others.\r\n        for(branch in xxTree) {\r\n          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\r\n            if(branch === nextType) {\r\n              // We know the next element will match, so jump twice.\r\n              searchListenerTree(handlers, type, xxTree[branch], i+2);\r\n            } else if(branch === currentType) {\r\n              // Current node matches, move into the tree.\r\n              searchListenerTree(handlers, type, xxTree[branch], i+1);\r\n            } else {\r\n              isolatedBranch = {};\r\n              isolatedBranch[branch] = xxTree[branch];\r\n              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);\r\n            }\r\n          }\r\n        }\r\n      } else if(xxTree._listeners) {\r\n        // We have reached the end and still on a '**'\r\n        searchListenerTree(handlers, type, xxTree, typeLength);\r\n      } else if(xxTree['*'] && xxTree['*']._listeners) {\r\n        searchListenerTree(handlers, type, xxTree['*'], typeLength);\r\n      }\r\n    }\r\n\r\n    return listeners;\r\n  }\r\n\r\n  function growListenerTree(type, listener) {\r\n\r\n    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n\r\n    //\r\n    // Looks for two consecutive '**', if so, don't add the event at all.\r\n    //\r\n    for(var i = 0, len = type.length; i+1 < len; i++) {\r\n      if(type[i] === '**' && type[i+1] === '**') {\r\n        return;\r\n      }\r\n    }\r\n\r\n    var tree = this.listenerTree;\r\n    var name = type.shift();\r\n\r\n    while (name !== undefined) {\r\n\r\n      if (!tree[name]) {\r\n        tree[name] = {};\r\n      }\r\n\r\n      tree = tree[name];\r\n\r\n      if (type.length === 0) {\r\n\r\n        if (!tree._listeners) {\r\n          tree._listeners = listener;\r\n        }\r\n        else {\r\n          if (typeof tree._listeners === 'function') {\r\n            tree._listeners = [tree._listeners];\r\n          }\r\n\r\n          tree._listeners.push(listener);\r\n\r\n          if (\r\n            !tree._listeners.warned &&\r\n            this._maxListeners > 0 &&\r\n            tree._listeners.length > this._maxListeners\r\n          ) {\r\n            tree._listeners.warned = true;\r\n            logPossibleMemoryLeak.call(this, tree._listeners.length, name);\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n      name = type.shift();\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // By default EventEmitters will print a warning if more than\r\n  // 10 listeners are added to it. This is a useful default which\r\n  // helps finding memory leaks.\r\n  //\r\n  // Obviously not all Emitters should be limited to 10. This function allows\r\n  // that to be increased. Set to zero for unlimited.\r\n\r\n  EventEmitter.prototype.delimiter = '.';\r\n\r\n  EventEmitter.prototype.setMaxListeners = function(n) {\r\n    if (n !== undefined) {\r\n      this._maxListeners = n;\r\n      if (!this._conf) this._conf = {};\r\n      this._conf.maxListeners = n;\r\n    }\r\n  };\r\n\r\n  EventEmitter.prototype.event = '';\r\n\r\n\r\n  EventEmitter.prototype.once = function(event, fn) {\r\n    return this._once(event, fn, false);\r\n  };\r\n\r\n  EventEmitter.prototype.prependOnceListener = function(event, fn) {\r\n    return this._once(event, fn, true);\r\n  };\r\n\r\n  EventEmitter.prototype._once = function(event, fn, prepend) {\r\n    this._many(event, 1, fn, prepend);\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.many = function(event, ttl, fn) {\r\n    return this._many(event, ttl, fn, false);\r\n  }\r\n\r\n  EventEmitter.prototype.prependMany = function(event, ttl, fn) {\r\n    return this._many(event, ttl, fn, true);\r\n  }\r\n\r\n  EventEmitter.prototype._many = function(event, ttl, fn, prepend) {\r\n    var self = this;\r\n\r\n    if (typeof fn !== 'function') {\r\n      throw new Error('many only accepts instances of Function');\r\n    }\r\n\r\n    function listener() {\r\n      if (--ttl === 0) {\r\n        self.off(event, listener);\r\n      }\r\n      return fn.apply(this, arguments);\r\n    }\r\n\r\n    listener._origin = fn;\r\n\r\n    this._on(event, listener, prepend);\r\n\r\n    return self;\r\n  };\r\n\r\n  EventEmitter.prototype.emit = function() {\r\n\r\n    this._events || init.call(this);\r\n\r\n    var type = arguments[0];\r\n\r\n    if (type === 'newListener' && !this.newListener) {\r\n      if (!this._events.newListener) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    var al = arguments.length;\r\n    var args,l,i,j;\r\n    var handler;\r\n\r\n    if (this._all && this._all.length) {\r\n      handler = this._all.slice();\r\n      if (al > 3) {\r\n        args = new Array(al);\r\n        for (j = 0; j < al; j++) args[j] = arguments[j];\r\n      }\r\n\r\n      for (i = 0, l = handler.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          handler[i].call(this, type);\r\n          break;\r\n        case 2:\r\n          handler[i].call(this, type, arguments[1]);\r\n          break;\r\n        case 3:\r\n          handler[i].call(this, type, arguments[1], arguments[2]);\r\n          break;\r\n        default:\r\n          handler[i].apply(this, args);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.wildcard) {\r\n      handler = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\r\n    } else {\r\n      handler = this._events[type];\r\n      if (typeof handler === 'function') {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          handler.call(this);\r\n          break;\r\n        case 2:\r\n          handler.call(this, arguments[1]);\r\n          break;\r\n        case 3:\r\n          handler.call(this, arguments[1], arguments[2]);\r\n          break;\r\n        default:\r\n          args = new Array(al - 1);\r\n          for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n          handler.apply(this, args);\r\n        }\r\n        return true;\r\n      } else if (handler) {\r\n        // need to make copy of handlers because list can change in the middle\r\n        // of emit call\r\n        handler = handler.slice();\r\n      }\r\n    }\r\n\r\n    if (handler && handler.length) {\r\n      if (al > 3) {\r\n        args = new Array(al - 1);\r\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n      }\r\n      for (i = 0, l = handler.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          handler[i].call(this);\r\n          break;\r\n        case 2:\r\n          handler[i].call(this, arguments[1]);\r\n          break;\r\n        case 3:\r\n          handler[i].call(this, arguments[1], arguments[2]);\r\n          break;\r\n        default:\r\n          handler[i].apply(this, args);\r\n        }\r\n      }\r\n      return true;\r\n    } else if (!this._all && type === 'error') {\r\n      if (arguments[1] instanceof Error) {\r\n        throw arguments[1]; // Unhandled 'error' event\r\n      } else {\r\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\r\n      }\r\n      return false;\r\n    }\r\n\r\n    return !!this._all;\r\n  };\r\n\r\n  EventEmitter.prototype.emitAsync = function() {\r\n\r\n    this._events || init.call(this);\r\n\r\n    var type = arguments[0];\r\n\r\n    if (type === 'newListener' && !this.newListener) {\r\n        if (!this._events.newListener) { return Promise.resolve([false]); }\r\n    }\r\n\r\n    var promises= [];\r\n\r\n    var al = arguments.length;\r\n    var args,l,i,j;\r\n    var handler;\r\n\r\n    if (this._all) {\r\n      if (al > 3) {\r\n        args = new Array(al);\r\n        for (j = 1; j < al; j++) args[j] = arguments[j];\r\n      }\r\n      for (i = 0, l = this._all.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          promises.push(this._all[i].call(this, type));\r\n          break;\r\n        case 2:\r\n          promises.push(this._all[i].call(this, type, arguments[1]));\r\n          break;\r\n        case 3:\r\n          promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));\r\n          break;\r\n        default:\r\n          promises.push(this._all[i].apply(this, args));\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.wildcard) {\r\n      handler = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\r\n    } else {\r\n      handler = this._events[type];\r\n    }\r\n\r\n    if (typeof handler === 'function') {\r\n      this.event = type;\r\n      switch (al) {\r\n      case 1:\r\n        promises.push(handler.call(this));\r\n        break;\r\n      case 2:\r\n        promises.push(handler.call(this, arguments[1]));\r\n        break;\r\n      case 3:\r\n        promises.push(handler.call(this, arguments[1], arguments[2]));\r\n        break;\r\n      default:\r\n        args = new Array(al - 1);\r\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n        promises.push(handler.apply(this, args));\r\n      }\r\n    } else if (handler && handler.length) {\r\n      handler = handler.slice();\r\n      if (al > 3) {\r\n        args = new Array(al - 1);\r\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n      }\r\n      for (i = 0, l = handler.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          promises.push(handler[i].call(this));\r\n          break;\r\n        case 2:\r\n          promises.push(handler[i].call(this, arguments[1]));\r\n          break;\r\n        case 3:\r\n          promises.push(handler[i].call(this, arguments[1], arguments[2]));\r\n          break;\r\n        default:\r\n          promises.push(handler[i].apply(this, args));\r\n        }\r\n      }\r\n    } else if (!this._all && type === 'error') {\r\n      if (arguments[1] instanceof Error) {\r\n        return Promise.reject(arguments[1]); // Unhandled 'error' event\r\n      } else {\r\n        return Promise.reject(\"Uncaught, unspecified 'error' event.\");\r\n      }\r\n    }\r\n\r\n    return Promise.all(promises);\r\n  };\r\n\r\n  EventEmitter.prototype.on = function(type, listener) {\r\n    return this._on(type, listener, false);\r\n  };\r\n\r\n  EventEmitter.prototype.prependListener = function(type, listener) {\r\n    return this._on(type, listener, true);\r\n  };\r\n\r\n  EventEmitter.prototype.onAny = function(fn) {\r\n    return this._onAny(fn, false);\r\n  };\r\n\r\n  EventEmitter.prototype.prependAny = function(fn) {\r\n    return this._onAny(fn, true);\r\n  };\r\n\r\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\r\n\r\n  EventEmitter.prototype._onAny = function(fn, prepend){\r\n    if (typeof fn !== 'function') {\r\n      throw new Error('onAny only accepts instances of Function');\r\n    }\r\n\r\n    if (!this._all) {\r\n      this._all = [];\r\n    }\r\n\r\n    // Add the function to the event listener collection.\r\n    if(prepend){\r\n      this._all.unshift(fn);\r\n    }else{\r\n      this._all.push(fn);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  EventEmitter.prototype._on = function(type, listener, prepend) {\r\n    if (typeof type === 'function') {\r\n      this._onAny(type, listener);\r\n      return this;\r\n    }\r\n\r\n    if (typeof listener !== 'function') {\r\n      throw new Error('on only accepts instances of Function');\r\n    }\r\n    this._events || init.call(this);\r\n\r\n    // To avoid recursion in the case that type == \"newListeners\"! Before\r\n    // adding it to the listeners, first emit \"newListeners\".\r\n    this.emit('newListener', type, listener);\r\n\r\n    if (this.wildcard) {\r\n      growListenerTree.call(this, type, listener);\r\n      return this;\r\n    }\r\n\r\n    if (!this._events[type]) {\r\n      // Optimize the case of one listener. Don't need the extra array object.\r\n      this._events[type] = listener;\r\n    }\r\n    else {\r\n      if (typeof this._events[type] === 'function') {\r\n        // Change to array.\r\n        this._events[type] = [this._events[type]];\r\n      }\r\n\r\n      // If we've already got an array, just add\r\n      if(prepend){\r\n        this._events[type].unshift(listener);\r\n      }else{\r\n        this._events[type].push(listener);\r\n      }\r\n\r\n      // Check for listener leak\r\n      if (\r\n        !this._events[type].warned &&\r\n        this._maxListeners > 0 &&\r\n        this._events[type].length > this._maxListeners\r\n      ) {\r\n        this._events[type].warned = true;\r\n        logPossibleMemoryLeak.call(this, this._events[type].length, type);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  EventEmitter.prototype.off = function(type, listener) {\r\n    if (typeof listener !== 'function') {\r\n      throw new Error('removeListener only takes instances of Function');\r\n    }\r\n\r\n    var handlers,leafs=[];\r\n\r\n    if(this.wildcard) {\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\r\n    }\r\n    else {\r\n      // does not use listeners(), so no side effect of creating _events[type]\r\n      if (!this._events[type]) return this;\r\n      handlers = this._events[type];\r\n      leafs.push({_listeners:handlers});\r\n    }\r\n\r\n    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\r\n      var leaf = leafs[iLeaf];\r\n      handlers = leaf._listeners;\r\n      if (isArray(handlers)) {\r\n\r\n        var position = -1;\r\n\r\n        for (var i = 0, length = handlers.length; i < length; i++) {\r\n          if (handlers[i] === listener ||\r\n            (handlers[i].listener && handlers[i].listener === listener) ||\r\n            (handlers[i]._origin && handlers[i]._origin === listener)) {\r\n            position = i;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (position < 0) {\r\n          continue;\r\n        }\r\n\r\n        if(this.wildcard) {\r\n          leaf._listeners.splice(position, 1);\r\n        }\r\n        else {\r\n          this._events[type].splice(position, 1);\r\n        }\r\n\r\n        if (handlers.length === 0) {\r\n          if(this.wildcard) {\r\n            delete leaf._listeners;\r\n          }\r\n          else {\r\n            delete this._events[type];\r\n          }\r\n        }\r\n\r\n        this.emit(\"removeListener\", type, listener);\r\n\r\n        return this;\r\n      }\r\n      else if (handlers === listener ||\r\n        (handlers.listener && handlers.listener === listener) ||\r\n        (handlers._origin && handlers._origin === listener)) {\r\n        if(this.wildcard) {\r\n          delete leaf._listeners;\r\n        }\r\n        else {\r\n          delete this._events[type];\r\n        }\r\n\r\n        this.emit(\"removeListener\", type, listener);\r\n      }\r\n    }\r\n\r\n    function recursivelyGarbageCollect(root) {\r\n      if (root === undefined) {\r\n        return;\r\n      }\r\n      var keys = Object.keys(root);\r\n      for (var i in keys) {\r\n        var key = keys[i];\r\n        var obj = root[key];\r\n        if ((obj instanceof Function) || (typeof obj !== \"object\") || (obj === null))\r\n          continue;\r\n        if (Object.keys(obj).length > 0) {\r\n          recursivelyGarbageCollect(root[key]);\r\n        }\r\n        if (Object.keys(obj).length === 0) {\r\n          delete root[key];\r\n        }\r\n      }\r\n    }\r\n    recursivelyGarbageCollect(this.listenerTree);\r\n\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.offAny = function(fn) {\r\n    var i = 0, l = 0, fns;\r\n    if (fn && this._all && this._all.length > 0) {\r\n      fns = this._all;\r\n      for(i = 0, l = fns.length; i < l; i++) {\r\n        if(fn === fns[i]) {\r\n          fns.splice(i, 1);\r\n          this.emit(\"removeListenerAny\", fn);\r\n          return this;\r\n        }\r\n      }\r\n    } else {\r\n      fns = this._all;\r\n      for(i = 0, l = fns.length; i < l; i++)\r\n        this.emit(\"removeListenerAny\", fns[i]);\r\n      this._all = [];\r\n    }\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\r\n\r\n  EventEmitter.prototype.removeAllListeners = function(type) {\r\n    if (arguments.length === 0) {\r\n      !this._events || init.call(this);\r\n      return this;\r\n    }\r\n\r\n    if (this.wildcard) {\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\r\n\r\n      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\r\n        var leaf = leafs[iLeaf];\r\n        leaf._listeners = null;\r\n      }\r\n    }\r\n    else if (this._events) {\r\n      this._events[type] = null;\r\n    }\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.listeners = function(type) {\r\n    if (this.wildcard) {\r\n      var handlers = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\r\n      return handlers;\r\n    }\r\n\r\n    this._events || init.call(this);\r\n\r\n    if (!this._events[type]) this._events[type] = [];\r\n    if (!isArray(this._events[type])) {\r\n      this._events[type] = [this._events[type]];\r\n    }\r\n    return this._events[type];\r\n  };\r\n\r\n  EventEmitter.prototype.eventNames = function(){\r\n    return Object.keys(this._events);\r\n  }\r\n\r\n  EventEmitter.prototype.listenerCount = function(type) {\r\n    return this.listeners(type).length;\r\n  };\r\n\r\n  EventEmitter.prototype.listenersAny = function() {\r\n\r\n    if(this._all) {\r\n      return this._all;\r\n    }\r\n    else {\r\n      return [];\r\n    }\r\n\r\n  };\r\n\r\n  if (typeof define === 'function' && define.amd) {\r\n     // AMD. Register as an anonymous module.\r\n    define(function() {\r\n      return EventEmitter;\r\n    });\r\n  } else if (typeof exports === 'object') {\r\n    // CommonJS\r\n    module.exports = EventEmitter;\r\n  }\r\n  else {\r\n    // Browser global.\r\n    window.EventEmitter2 = EventEmitter;\r\n  }\r\n}();\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/eventemitter2/lib/eventemitter2.js\n// module id = 0\n// module chunks = 0","\"use strict\";\r\n/* Copyright (c) 2013 Billy Tetrud - Free to use for any purpose: MIT License*/\r\n\r\nvar noop = function() {}\r\n\r\nvar prototypeName='prototype', undefined, protoUndefined='undefined', init='init', ownProperty=({}).hasOwnProperty; // minifiable variables\r\nfunction proto() {\r\n    var args = arguments // minifiable variables\r\n\r\n    if(args.length == 1) {\r\n        var parent = {init: noop}\r\n        var prototypeBuilder = args[0]\r\n\r\n    } else { // length == 2\r\n        var parent = args[0]\r\n        var prototypeBuilder = args[1]\r\n    }\r\n\r\n    // special handling for Error objects\r\n    var namePointer = {}    // name used only for Error Objects\r\n    if([Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError].indexOf(parent) !== -1) {\r\n        parent = normalizeErrorObject(parent, namePointer)\r\n    }\r\n\r\n    // set up the parent into the prototype chain if a parent is passed\r\n    var parentIsFunction = typeof(parent) === \"function\"\r\n    if(parentIsFunction) {\r\n        prototypeBuilder[prototypeName] = parent[prototypeName]\r\n    } else {\r\n        prototypeBuilder[prototypeName] = parent\r\n    }\r\n\r\n    // the prototype that will be used to make instances\r\n    var prototype = new prototypeBuilder(parent)\r\n    namePointer.name = prototype.name\r\n\r\n    // if there's no init, assume its inheriting a non-proto class, so default to applying the superclass's constructor.\r\n    if(!prototype[init] && parentIsFunction) {\r\n        prototype[init] = function() {\r\n            parent.apply(this, arguments)\r\n        }\r\n    }\r\n\r\n    // constructor for empty object which will be populated via the constructor\r\n    var F = function() {}\r\n        F[prototypeName] = prototype    // set the prototype for created instances\r\n\r\n    var constructorName = prototype.name?prototype.name:''\r\n    if(prototype[init] === undefined || prototype[init] === noop) {\r\n        var ProtoObjectFactory = new Function('F',\r\n            \"return function \" + constructorName + \"(){\" +\r\n                \"return new F()\" +\r\n            \"}\"\r\n        )(F)\r\n    } else {\r\n        // dynamically creating this function cause there's no other way to dynamically name a function\r\n        var ProtoObjectFactory = new Function('F','i','u','n', // shitty variables cause minifiers aren't gonna minify my function string here\r\n            \"return function \" + constructorName + \"(){ \" +\r\n                \"var x=new F(),r=i.apply(x,arguments)\\n\" +    // populate object via the constructor\r\n                \"if(r===n)\\n\" +\r\n                    \"return x\\n\" +\r\n                \"else if(r===u)\\n\" +\r\n                    \"return n\\n\" +\r\n                \"else\\n\" +\r\n                    \"return r\\n\" +\r\n            \"}\"\r\n        )(F, prototype[init], proto[protoUndefined]) // note that n is undefined\r\n    }\r\n\r\n    prototype.constructor = ProtoObjectFactory;    // set the constructor property on the prototype\r\n\r\n    // add all the prototype properties onto the static class as well (so you can access that class when you want to reference superclass properties)\r\n    for(var n in prototype) {\r\n        addProperty(ProtoObjectFactory, prototype, n)\r\n    }\r\n\r\n    // add properties from parent that don't exist in the static class object yet\r\n    for(var n in parent) {\r\n        if(ownProperty.call(parent, n) && ProtoObjectFactory[n] === undefined) {\r\n            addProperty(ProtoObjectFactory, parent, n)\r\n        }\r\n    }\r\n\r\n    ProtoObjectFactory.parent = parent;            // special parent property only available on the returned proto class\r\n    ProtoObjectFactory[prototypeName] = prototype  // set the prototype on the object factory\r\n\r\n    return ProtoObjectFactory;\r\n}\r\n\r\nproto[protoUndefined] = {} // a special marker for when you want to return undefined from a constructor\r\n\r\nmodule.exports = proto\r\n\r\nfunction normalizeErrorObject(ErrorObject, namePointer) {\r\n    function NormalizedError() {\r\n        var tmp = new ErrorObject(arguments[0])\r\n        tmp.name = namePointer.name\r\n\r\n        this.message = tmp.message\r\n        if(Object.defineProperty) {\r\n            /*this.stack = */Object.defineProperty(this, 'stack', { // getter for more optimizy goodness\r\n                get: function() {\r\n                    return tmp.stack\r\n                },\r\n                configurable: true // so you can change it if you want\r\n            })\r\n        } else {\r\n            this.stack = tmp.stack\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    var IntermediateInheritor = function() {}\r\n        IntermediateInheritor.prototype = ErrorObject.prototype\r\n    NormalizedError.prototype = new IntermediateInheritor()\r\n\r\n    return NormalizedError\r\n}\r\n\r\nfunction addProperty(factoryObject, prototype, property) {\r\n    try {\r\n        var info = Object.getOwnPropertyDescriptor(prototype, property)\r\n        if(info.get !== undefined || info.get !== undefined && Object.defineProperty !== undefined) {\r\n            Object.defineProperty(factoryObject, property, info)\r\n        } else {\r\n            factoryObject[property] = prototype[property]\r\n        }\r\n    } catch(e) {\r\n        // do nothing, if a property (like `name`) can't be set, just ignore it\r\n    }\r\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/proto/proto.js\n// module id = 1\n// module chunks = 0","var EventEmitter = require('eventemitter2')\r\nvar proto = require(\"proto\")\r\n\r\nvar utils = require(\"./utils\")\r\nvar DuplexEventEmitter = require('./DuplexEventEmitter')\r\n\r\n// enums\r\nvar receive = 0\r\nvar respond = 1\r\nvar stream = 2\r\n\r\nvar defaultMaxId = 9007199254740992 // 2^53\r\nvar reservedFireCommands = {close:1,idDiscontinuity:1}\r\nvar reservedRequestAndStreamCommands = {close:1,idDiscontinuity:1}\r\nvar reservedRequestAndStreamErrorCommand = {error:1}\r\nvar reservedListeningCommands = {close:1}\r\nvar reservedRespondAndStreamListenCommands = {idDiscontinuity:1}\r\nvar reservedEventListeningEvents = {order:1}\r\nvar reservedStreamEmissionEvents = {orderNumberDiscontinuity:1}\r\n\r\n\r\nvar buffer = 50 // some buffer for message header stuff\r\n\r\nvar PeerError = proto(Error, function() {\r\n    this.name = \"PeerError\"\r\n})\r\n\r\n// An instance of RpepCore can emit the following events:\r\n    // 'close' - Fired once the listening server has been closed\r\n    // 'error' - Fired if there was an error related to listening\r\nmodule.exports = proto(EventEmitter, function() {\r\n\r\n    // static properties\r\n\r\n    // an error that, when thrown, sends the error as an error response to the other Peer (including iterable properties, but not including the stack)\r\n    this.PeerError = PeerError\r\n\r\n    // instance properties\r\n\r\n    // transport is an object with the following methods:\r\n        // connect(/*transport connect parameters... */, rpepOptions) - connects to a websocket server\r\n            // transport connect parameters... - A variable number of transport connect parameters passed into rpepPeer.connect\r\n            // rpepOptions - An object containing the maxSendSize and maxReceiveSize options\r\n            // returns a connection object\r\n               // with the following methods:\r\n                // send(message)\r\n                // close() - Closes the connection in a way that actively informs the other Peer about closure.\r\n                // drop() - (Optional) Closes the connection without informing the other Peer.\r\n               // and the following event-handler functions (which will only be called once):\r\n                // onOpen(callback)\r\n                // onClose(callback) - (Optional) If an error happens that causes connection closure, this should still be fired, or the connection will be assumed to still be open. If not given, a \"close\" fire-and-forget message will be sent before connection closure if the Peer is a server, and that \"close\" message will be listened for if its a client Peer.\r\n                // onMessage(callback)\r\n                // onError(callback)\r\n        // listen(/*transport listen parameters... */, rpepOptions, callback) - (Optional) Listens for connectiosn and calls `callback` when a connection comes through.\r\n            // transport listen parameters... - A variable number of transport listen parameters passed into rpepPeer.listen\r\n            // Parameters:\r\n                // rpepOptions - An object containing the maxSendSize and maxReceiveSize options\r\n                // callback(request) - Called when a connection request comes through.\r\n                    // `request` has the methods:\r\n                        // accept() - Returns a connection object (with the same API as the object that `connect` returns).\r\n                        // reject()\r\n                    // and the following property:\r\n                        // rawRequest - The raw request from the transport\r\n            // returns an object\r\n               // with the following method:\r\n                // close() - closes the listening server\r\n               // and the following event-handler functions (which will only be called once):\r\n                // onListening(callback) - Called when the server starts listening\r\n                // onClose(callback) - Called when the server stops listening\r\n                // onError(callback) - Called if listening couldn't be started\r\n        // connection(connectionArgument) - Returns a connection object\r\n            // connectionArgument - The value returned from `connect` above or from the `accept` function in a `listen` callback\r\n    // serialization is an object with the following methods:\r\n        // serialize(javascriptObject) - Returns the javascript object in serialized form (something the transport can process, most likely a string or Buffer)\r\n        // deserialize(serializedObject) - Returns a javascript object reprented by the serializedObject\r\n    // options:\r\n        // maxSendSize - The maximum byte-length a sent message can be (Default: no limit)\r\n        // maxReceiveSize - The maximum byte-length a received message can be (Default: no limit)\r\n        // maxId - (Default: 2^53) The maximum id to use for request and stream commands, as well as stream order id numbers\r\n        // closeTimeout - (Default: 30,000 ms) The number of milliseconds to wait for outstanding requests and streams to complete before closing the connection. If the timeout is reached, an 'error'\r\n        // sendCommandErrorInfo - (Default:true)\r\n            // If true,\r\n                // errors will automatically be sent to the other Peer if their command is unparsable, and\r\n                // the first part of the command will be sent with an \"invalidMessage\" error\r\n            // Otherwise, the error will be ignored (but handleable via rawHandle or preHandle, depending on the case).\r\n    this.init = function(transport, serialization, options) {\r\n        EventEmitter.call(this) // superclass constructor\r\n\r\n        if(!options) options = {}\r\n\r\n        this.transport = transport\r\n        this.serialization = serialization\r\n        this.options = options\r\n        if(this.options.maxId === undefined) this.options.maxId = defaultMaxId\r\n        if(this.options.sendCommandErrorInfo === undefined) this.options.sendCommandErrorInfo = true\r\n\r\n        this.commands = {}\r\n        // this.defaultHandler\r\n        // this.preHandler\r\n        // this.rawHandler\r\n\r\n        // this.listener\r\n    }\r\n\r\n    // returns a future open connection\r\n    // takes in any number of transport specific connection arguments\r\n    this.connect = function() {\r\n        var args = Array.prototype.slice.call(arguments)\r\n\r\n        var that = this\r\n        return new Promise(function(resolve, reject) {\r\n            var connection = that.transport.connect.apply(that.transport.connect, args.concat([that.options]))\r\n\r\n            var onOpenCalled = false, errors = []\r\n            connection.onOpen(function() {\r\n                onOpenCalled = true\r\n                resolve(rpepConn)\r\n            })\r\n\r\n            var rpepConn = RpepConnection(that, connection, {isServer:false, onClose: function() {\r\n                if(!onOpenCalled) {\r\n                    var message = \"Connection couldn't be opened\"\r\n                    if(errors.length > 0) {\r\n                        message+=': \\n'+errors.join('\\n')\r\n                    }\r\n\r\n                    var e = err(\"connectionFailure\", message)\r\n                    e.errors = errors\r\n                    reject(e)\r\n                }\r\n            }})\r\n\r\n            connection.onError(function(e) {\r\n                errors.push(e)\r\n            })\r\n        })\r\n    }\r\n\r\n    // returns a future that resolves successfully when the server has begun listening and resolves to an error if listening couldn't be started\r\n    this.listen = function(/*variable number of listen parameters, requestHandler*/) {\r\n        var args = Array.prototype.slice.call(arguments)\r\n        var requestHandler = args[args.length-1]\r\n        var transportListenArguments = args.slice(0,-1)\r\n\r\n        var that = this\r\n        return new Promise(function(resolve, reject) {\r\n            if(that.listener !== undefined) {\r\n                throw new Error(\"Rpep object already listening!\")\r\n            }\r\n\r\n            that.listener = that.transport.listen.apply(that.transport, transportListenArguments.concat([that.options, function(request) {\r\n                requestHandler({\r\n                    accept: function() {\r\n                        var connection = request.accept.apply(that,arguments)\r\n                        return RpepConnection(that, connection, {isServer:true})\r\n                    },\r\n                    reject: function() {\r\n                        request.reject.apply(that, arguments)\r\n                    },\r\n                    rawRequest: request\r\n                })\r\n            }]))\r\n\r\n            var listening = false\r\n            that.listener.onListening(function() {\r\n                listening = true\r\n                that.emit('listening')\r\n                resolve()\r\n            })\r\n            that.listener.onError(function(e) {\r\n                that.emit('error',e)\r\n            })\r\n            that.listener.onClose(function(e) {\r\n                that.listener = undefined\r\n                that.emit('close')\r\n                if(listening === false)\r\n                    reject()\r\n            })\r\n        })\r\n    }\r\n\r\n    // closes a listening websocket server\r\n    // no-op if the server is already closed\r\n    this.close = function() {\r\n        if(this.listener)\r\n            this.listener.close()\r\n    }\r\n\r\n    // sets up a handler to receive a fireAndForget call\r\n    this.receive = function(command, handler) {\r\n        addCommand(this, receive, command, handler)\r\n    }\r\n\r\n    // sets up a handler to handle request-response calls\r\n    // the handler can either return\r\n        // A (possibly future) value, which will be sent as a response. Or,\r\n        // A (possibly future) Error object. The 'message' will be sent as the `error`, and any other iterable properties of the object will be added as the `data`.\r\n    this.respond = function(command, handler) {\r\n        addCommand(this, respond, command, handler)\r\n    }\r\n\r\n    // sets up a handler to handle event-steam calls\r\n    this.stream = function(command, handler) {\r\n        if(!(handler instanceof Function)) {\r\n            throw new Error(\"rpep.stream requires a callback as the second argument\")\r\n        }\r\n        addCommand(this, stream, command, handler)\r\n    }\r\n\r\n    // Sets a default command handler\r\n    this.default = function(handler) {\r\n        if(this.defaultHandler !== undefined)\r\n            throw handlerError('default handler')\r\n\r\n        this.defaultHandler = handler\r\n    }\r\n\r\n    // Sets up a function that is run before every command\r\n    // If \"ignore\" is returned from `handler`, the corresponding receive, respond, stream, or default handler will not be called\r\n    this.preHandle = function(handler) {\r\n        if(this.preHandler !== undefined)\r\n            throw handlerError('preHandle')\r\n\r\n        this.preHandler = handler\r\n    }\r\n\r\n    // Sets up a function that is run before the command is even parsed\r\n    // If \"ignore\" is returned from `handler`, preHandle and the corresponding receive, respond, stream, or default handler will not be called\r\n    this.rawHandle = function(handler) {\r\n        if(this.rawHandler !== undefined)\r\n            throw handlerError('rawHandle')\r\n\r\n        this.rawHandler = handler\r\n    }\r\n\r\n    // private\r\n\r\n    // type should either be `receive`, `respond`, or `stream`\r\n    function addCommand(that, type, command, handler) {\r\n        if(that.commands[command] !== undefined)\r\n            throw handlerError('handler for \"'+command+'\"')\r\n        if(command in reservedListeningCommands)\r\n            throw new Error(\"Can't setup a handler for the command '\"+command+\"', because it's reserved for internal use.\")\r\n        if((type === respond || type === stream) && command in reservedRespondAndStreamListenCommands)\r\n            throw new Error(\"Can't setup a receive or stream handler for the command '\"+command+\"', because it's reserved for as a receive command. If you'd like to listen for this command, use `receive`.\")\r\n\r\n        that.commands[command] = {type: type, handler: handler}\r\n    }\r\n\r\n    function handlerError(handlerName) {\r\n        return new Error('A '+handlerName+' already exists! You can only have one handler per command.')\r\n    }\r\n})\r\n\r\n// An instance of RpepConnection can emit the following events:\r\n    // close() - Fired once the connection has been closed\r\n    // openMessage() - Fired when an 'open' message is received. For internal use only.\r\n    // closeMessage() - Fired when a 'close' message is received. For internal use only.\r\n    // error(e) - An error event is emitted from the connection in the following cases:\r\n        // When the transport calls its onError callback\r\n        // When an error is thrown from a stream or receive handler\r\n        // When an error that isn't a PeerError is thrown from a respond handler\r\n        // If an unexpected internal exception is thrown when handling a message\r\n        // If the closeTimeout is reached and there are still open requests or streams. This error will contain info about what requests and streams are still open.\r\nvar RpepConnection = proto(EventEmitter, function() {\r\n\r\n    // connectionOptions\r\n        // isServer - Should be true if the connection is being creatd by a server, false otherwise\r\n        // onClose - A function that will be called in the onClose event before the 'close' event is emitted\r\n    this.init = function(rpepCoreObject, connectionObject, connectionOptions) {\r\n        EventEmitter.call(this) // superclass constructor\r\n\r\n        this.transport = rpepCoreObject.transport\r\n        this.serialization = rpepCoreObject.serialization\r\n        this.commands = rpepCoreObject.commands\r\n\r\n        this.defaultHandler = rpepCoreObject.defaultHandler\r\n        this.preHandler = rpepCoreObject.preHandler\r\n        this.rawHandler = rpepCoreObject.rawHandler\r\n\r\n        this.maxSendSize = rpepCoreObject.options.maxSendSize\r\n        this.maxReceiveSize = rpepCoreObject.options.maxReceiveSize\r\n        this.sendCommandErrorInfo = rpepCoreObject.options.sendCommandErrorInfo\r\n        this.maxId = rpepCoreObject.options.maxId\r\n        this.closeTimeout = rpepCoreObject.options.closeTimeout || 30000\r\n        this.server = connectionOptions.isServer\r\n\r\n        this.connection = connectionObject\r\n        this.connected = true\r\n        this.closing = false\r\n        this.sessionData = {}\r\n        this.commandState = {}\r\n        var connectionHasBeenOpened = false\r\n\r\n        Object.defineProperty(this, 'rawConnection', { get: function() {\r\n            return this.connection.rawConnection\r\n        }})\r\n        \r\n        if(this.server)\r\n            this.nextId = 0\r\n        else\r\n            this.nextId = 1\r\n\r\n        var that = this\r\n\r\n        if(this.connection.onClose) {\r\n            this.connection.onClose(function() {\r\n                if(connectionOptions.onClose)\r\n                    connectionOptions.onClose()\r\n\r\n                that.connected = false\r\n                that.emit('close')\r\n            })\r\n        } else {\r\n            this.on('closeMessage', function() {\r\n                that.connected = false\r\n                that.emit('close')\r\n            })\r\n        }\r\n\r\n        this.connection.onMessage(function(rawMessage) {\r\n            handle(that, rawMessage)\r\n        })\r\n        this.connection.onOpen(function() {\r\n            connectionHasBeenOpened = true\r\n        })\r\n        this.connection.onError(function(e) {\r\n            if(connectionHasBeenOpened)\r\n                that.emit('error', e)\r\n        })\r\n    }\r\n\r\n    // closes the connection\r\n    this.close = function() {\r\n        var that = this\r\n        \r\n        if(this.connected && !this.closing) {\r\n            this.closing = true\r\n            if(Object.keys(this.commandState).length === 0) {\r\n                closeInternal(this)\r\n            } else {\r\n                this.closeTimeoutHandle = setTimeout(function() {\r\n                    that.closeTimeoutHandle = undefined\r\n                    closeInternal(that)\r\n                },this.closeTimeout)\r\n            }\r\n        }\r\n    }\r\n    // drops the connection without informing the other Peer if supported, otherwise with informing the other Peer\r\n    this.drop = function() {\r\n        if(this.connected && this.connection.drop) {\r\n            this.connection.drop()\r\n        } else {\r\n            this.close()\r\n        }\r\n    }\r\n\r\n    // fire and forget message\r\n    // If `command` is \"error\", the data must be an object that contains a message property (eg an Error object). Any other iterable properties will be added as data.\r\n    this.fire = function(command/*, data...*/) {\r\n        if(command === 'error') {\r\n            if(arguments[1].message === undefined)\r\n                throw new Error(\"The data for an 'error' fire-and-forget message must have a 'message' property (eg an Error object has a message property)\")\r\n            else if(arguments.length !== 2)\r\n                throw new Error(\"An 'error' fire-and-forget message can only take one argument - the error.\")\r\n        }\r\n\r\n        if(command in reservedFireCommands) {\r\n            throw new Error(\"Can't fire an '\"+command+\"' event directly; '\"+command+\"' is a global command reserved for internal use.\")\r\n        }\r\n\r\n        var message = [command]\r\n        if(command === 'error') {\r\n            var error = arguments[1]\r\n            var errorData = {}\r\n            for(var k in error) {\r\n                if(k !== 'message')\r\n                    errorData[k] = error[k]\r\n            }\r\n\r\n            message.push(error.message, errorData)\r\n        } else {\r\n            addData(message, arguments)\r\n        }\r\n\r\n        send(this, message)\r\n    }\r\n\r\n    // request response\r\n    this.request = function(command/*, data...*/) {\r\n        if(command in reservedRequestAndStreamCommands)\r\n            throw new Error(\"Can't do a '\"+command+\"' request directly; '\"+command+\"' is a global command reserved for internal use.\")\r\n        if(command in reservedRequestAndStreamErrorCommand)\r\n            throw new Error(\"Can't do an 'error' request; 'error' is reserved for global fire-and-forget errors.\")\r\n        if(this.commandState[this.nextId] !== undefined)\r\n            throw new Error('There is already a callback for id: '+this.nextId)\r\n\r\n        var message = [command, this.nextId]\r\n        addData(message, arguments)\r\n\r\n        send(this, message)\r\n\r\n        var theResolver = utils.resolver()\r\n        theResolver.command = command\r\n        this.commandState[this.nextId] = theResolver\r\n\r\n        incrementId(this)\r\n\r\n        return theResolver.f\r\n    }\r\n\r\n    // full-duplex event stream\r\n    this.streamConnect = function(command/*, data...*/) {\r\n        if(command in reservedRequestAndStreamCommands)\r\n            throw new Error(\"Can't open a '\"+command+\"' stream directly; '\"+command+\"' is a global command reserved for internal use.\")\r\n        if(command in reservedRequestAndStreamErrorCommand)\r\n            throw new Error(\"Can't open an 'error' stream; 'error' is reserved for global fire-and-forget errors.\")\r\n        if(this.commandState[this.nextId] !== undefined)\r\n            throw new Error('There is already a callback for id: '+this.nextId)\r\n\r\n        var message = [command, this.nextId]\r\n        addData(message, arguments)\r\n\r\n        var emitter = this.commandState[this.nextId] = createStreamEmiter(this, this.nextId)\r\n        emitter.command = command\r\n        send(this, message)\r\n\r\n        incrementId(this)\r\n\r\n        return emitter\r\n    }\r\n\r\n    // private\r\n\r\n    function serialize(that,data) {\r\n        return that.serialization.serialize(data)\r\n    }\r\n    function deserialize(that,serializedData) {\r\n        return that.serialization.deserialize(serializedData)\r\n    }\r\n\r\n    function closeInternal(that) {\r\n        if(that.closeTimeoutHandle !== undefined) {\r\n            clearTimeout(that.closeTimeoutHandle)\r\n        }\r\n\r\n        var ids = Object.keys(that.commandState)\r\n        if(ids.length > 0) {\r\n            var errorMessage = \"Connection has been closed after a \"+that.closeTimeout+\"ms timeout and some pending requests and streams remain unfulfilled. \"+\r\n                                \"The following requests and streams were still active up until the timeout:\\n\"\r\n            \r\n            var activeCommandStates = []\r\n            for(var k in that.commandState) {\r\n                var info = that.commandState[k]\r\n                if(info instanceof RpepDuplexEventEmitter) { // stream\r\n                    if(info.endMessageSent) {\r\n                        activeCommandStates.push(\"* Stream \"+k+\" '\"+info.command+\"' waiting for other side to 'end'\")\r\n                    } else if(info.endMessageReceived) {\r\n                        activeCommandStates.push(\"* Stream \"+k+\" '\"+info.command+\"' has received 'end' but hasn't sent 'end'\")\r\n                    } else {\r\n                        activeCommandStates.push(\"* Stream \"+k+\" '\"+info.command+\"' is still active\")\r\n                    }\r\n                } else if(info.f !== undefined) { // request\r\n                    activeCommandStates.push(\"* Request \"+k+\" to '\"+info.command+\"'\")\r\n                } else { // response\r\n                    activeCommandStates.push(\"* Response \"+k+\" for '\"+info.command+\"'\")\r\n                }\r\n            }\r\n\r\n            errorMessage+=activeCommandStates.join('\\n')\r\n            var e = new Error(errorMessage)\r\n            e.ids = ids\r\n\r\n            that.commandState = {} // clear command state so anything that comes through will error - todo: should we just leave it be tho?\r\n\r\n            that.emit('error', e)\r\n        }\r\n\r\n        if(that.connection.onClose === undefined) {\r\n            send(that, ['close'])\r\n        }\r\n\r\n        that.connection.close()\r\n        that.connection = undefined\r\n    }\r\n    // If the connection is closing and it's a clean close, close it out.\r\n    function checkCleanClose(that) {\r\n        if(that.closing && Object.keys(that.commandState).length === 0) {\r\n            closeInternal(that)\r\n        }\r\n    }\r\n\r\n    // may send an idDiscontinuity message\r\n    function incrementId(that) {\r\n        var prevId = that.nextId\r\n        do {\r\n            that.nextId += 2\r\n            if(that.nextId > that.maxId) {\r\n                that.nextId = that.nextId%2 // reset to 0 or 1\r\n            }\r\n        } while(that.nextId in that.commandState && prevId !== that.nextId)\r\n\r\n        if(prevId === that.nextId)\r\n            throw new Error(\"No valid rpep IDs left to use.\")\r\n        if(that.nextId !== prevId+2)\r\n            send(that, ['idDiscontinuity', [prevId,that.nextId]])\r\n    }\r\n\r\n    function addData(message, theArguments) {\r\n        var data = Array.prototype.slice.call(theArguments, 1)\r\n        if(data.length === 1)\r\n            message.push(data[0])\r\n        else if(data.length > 1)\r\n            message.push(data)\r\n    }\r\n\r\n    // returns the argument if its array, or wraps it in an array if not\r\n    function getArrayData(data) {\r\n        if(data === undefined)\r\n            return []\r\n        else if(data instanceof Array)\r\n            return data\r\n        else\r\n            return [data]\r\n    }\r\n\r\n    // may send an disctontinuity message\r\n    function incrementOrderNumber(that, emitter) {\r\n        emitter.nextOrderNumber += 1\r\n        if(emitter.nextOrderNumber > that.maxId) {\r\n            var prevNumber = emitter.nextOrderNumber-1\r\n            emitter.nextOrderNumber = 0\r\n            sendEvent(that, emitter,  emitter.id, 'orderNumberDiscontinuity', ['', prevNumber, emitter.nextOrderNumber])\r\n        }\r\n    }\r\n\r\n    // error is expected to be an exception object (with a message property at least)\r\n    function createErrorInfo(error) {\r\n        var data = {}, any = false\r\n        for(var k in error) {\r\n            if(k !== 'message') {\r\n                data[k] = error[k]\r\n                any = true\r\n            }\r\n        }\r\n\r\n        var errorInfo = [error.message]\r\n        if(any) {\r\n            errorInfo.push(data)\r\n        }\r\n\r\n        return errorInfo\r\n    }\r\n\r\n    function createErrorFromMessage(errorMessage, errorData) {\r\n        var e = new Error(errorMessage)\r\n        for(var k in errorData) {\r\n            if(k !== 'message')\r\n                e[k] = errorData[k]\r\n        }\r\n\r\n        return e\r\n    }\r\n\r\n    function createStreamEmiter(that, id) {\r\n        var emitter = RpepDuplexEventEmitter(function onEmit(event/*, data*/) {\r\n            if(emitter.endMessageSent)\r\n                throw new Error(\"Stream 'end' event has been sent, can't send more events.\")\r\n            if(event in reservedStreamEmissionEvents)\r\n                throw new Error(\"Can't emit the '\"+event+\"' event directly; '\"+event+\"' is reserved for internal use.\")\r\n            if(event === 'error') {\r\n                if(arguments[1].message === undefined)\r\n                    throw new Error(\"The data for an 'error' event must have a 'message' property (eg an Error object has a message property)\")\r\n                else if(arguments.length !== 2)\r\n                    throw new Error(\"An 'error' event can only take one argument - the error.\")\r\n            }\r\n\r\n            sendEvent(that, emitter, id, event, arguments)\r\n        })\r\n\r\n        emitter.id = id\r\n        emitter.orderingData = false\r\n        emitter.nextOrderNumber = 0\r\n        emitter.endMessageSent = false\r\n        return emitter\r\n    }\r\n\r\n    // raw send\r\n    function send(that, message) {\r\n        var serializedMessage = serialize(that, message)\r\n        if(that.maxSendSize !== undefined && serializedMessage.length > that.maxSendSize) {\r\n            var e = err('maxMessageSizeExceeded')\r\n            e.messageSize = serializedMessage.length\r\n            throw e\r\n        }\r\n\r\n        if(that.connected) {\r\n            that.connection.send(serializedMessage)\r\n        } else {\r\n            throw Error('Connection is closed')\r\n        }\r\n    }\r\n\r\n    // args will contain [event, data...]\r\n    function sendEvent(that, emitter, id, event, args) {\r\n        var message = [id]\r\n        if(emitter.orderingData)\r\n            message.push(emitter.nextOrderNumber)\r\n\r\n        message.push(event)\r\n\r\n        if(event === 'error')\r\n            message.push(createErrorInfo(args[1]))\r\n        else\r\n            addData(message, args)\r\n\r\n        send(that, message)\r\n\r\n        if(event === 'end') {\r\n            emitter.endMessageSent = true\r\n            if(emitter.endMessageReceived) {\r\n                delete that.commandState[id] // ensures that \"rpepIdNotFound\" will be returned if this stream continues to be communicated on\r\n                checkCleanClose(that)\r\n            }\r\n        } else if(emitter.orderingData) {\r\n            incrementOrderNumber(that, emitter)\r\n        }\r\n    }\r\n\r\n    function handle(that, rawMessage) {\r\n        try {\r\n            if(that.rawHandler) {\r\n                if(that.rawHandler.call(that, rawMessage) === 'ignore') {\r\n                    return\r\n                }\r\n            }\r\n\r\n            try {\r\n                var message = deserialize(that, rawMessage)\r\n            } catch(e) {\r\n                if(that.sendCommandErrorInfo) {\r\n                    try {\r\n                        that.fire(\"error\", {message: \"unparsableCommand\", rawMessage: rawMessage})\r\n                    } catch(e) {\r\n                        if(e.message === 'maxMessageSizeExceeded')\r\n                            that.fire(\"error\", {message: \"unparsableCommand\", rawMessage: rawMessage.slice(0,200)})\r\n                        else throw e\r\n                    }\r\n                }\r\n\r\n                that.emit('error', createUnparsableCommandError(rawMessage))\r\n                return\r\n            }\r\n\r\n            if(that.preHandler) {\r\n                if(that.preHandler.call(that, message) === 'ignore') {\r\n                    return\r\n                }\r\n            }\r\n\r\n            var type0 = typeof(message[0])\r\n            if(type0 === 'string') {\r\n                // open and close fire-and-forget connection establishment message\r\n                if(message.length === 1 && message[0] === 'close') {\r\n                    that.emit(\"closeMessage\")\r\n                    return\r\n                }\r\n\r\n                var commandInfo = that.commands[message[0]]\r\n                if(commandInfo === undefined) {\r\n                    if(that.defaultHandler !== undefined) {\r\n                        that.defaultHandler.call(that,message)\r\n                        return\r\n                    }\r\n                    if(message[0] === 'error')\r\n                        throw createErrorFromMessage(message[1], message[2])\r\n                    if(message[0] !== 'idDiscontinuity') \r\n                        that.fire('error', {message: \"noSuchCommand\", command: message[0]})\r\n\r\n                    return\r\n                }\r\n\r\n                if(commandInfo.type === receive) {\r\n                    if(message[0] === 'error')\r\n                        var data = [createErrorFromMessage(message[1], message[2])]\r\n                    else\r\n                        var data = getArrayData(message[1])\r\n\r\n                    commandInfo.handler.apply(that, data)\r\n                } else if(commandInfo.type === respond) {\r\n                    var id = message[1]\r\n                    if(!validateId(that, id)) {\r\n                        return\r\n                    }\r\n\r\n                    that.commandState[id] = {command: message[0]}\r\n                    Promise.resolve().then(function() {\r\n                        return commandInfo.handler.apply(that, getArrayData(message[2]).concat([id]))\r\n                    }).then(function(result) {\r\n                        delete that.commandState[id]\r\n                        send(that, [id,result])\r\n                    }).catch(function(e) {\r\n                        delete that.commandState[id]\r\n                        if(e instanceof PeerError) {\r\n                            var errorInfo = createErrorInfo(e)\r\n                        } else {\r\n                            var errorInfo = ['unexpectedPeerError', {}]\r\n                            that.emit('error', e)\r\n                        }\r\n\r\n                        send(that, [id].concat(errorInfo))\r\n                    })\r\n                } else if(commandInfo.type === stream) {\r\n                    var id = message[1]\r\n                    if(!validateId(that, id)) {\r\n                        return\r\n                    }\r\n                    \r\n                    var emitter = that.commandState[id] = createStreamEmiter(that,id)\r\n                    emitter.command = message[0]\r\n\r\n                    try {\r\n                        commandInfo.handler.apply(that, [emitter].concat(getArrayData(message[2])).concat([id]))\r\n                    } catch(e) {\r\n                        that.emit('error', e) // note that PeerError objects are treated like normal Errors here - to emit an error, you must emit an 'error' event from the passed emitter\r\n                    }\r\n                } else {\r\n                    throw err(\"invalidCommandType\", \"Invalid command type: \"+commandInfo.type)\r\n                }\r\n\r\n            } else if(type0 === 'number') {\r\n                if(!(message[0] in that.commandState)) {\r\n                    that.fire(\"error\", {message: \"rpepIdNotFound\", id: message[0]})\r\n                    return\r\n                }\r\n\r\n                var info = that.commandState[message[0]]\r\n                if(info instanceof RpepDuplexEventEmitter) { //stream\r\n                    var emitter = info\r\n                    if(typeof(message[1]) === 'string') {          // message without order number\r\n                        var event = message[1], eventData = message[2]\r\n                    } else if(typeof(message[2]) === 'string') {   // message with order number\r\n                        var orderNumber = message[1], event = message[2], eventData = message[3]\r\n                    } else {\r\n                        throw err(\"invalidStreamMessage\", \"Received invalid stream message: couldn't find string event name at position 1 or 2 in the message\")\r\n                    }\r\n\r\n                    if(event === 'order') {\r\n                        emitter.orderingData = eventData === true\r\n                    } else {\r\n                        if(event === 'error') {\r\n                            var error = createErrorFromMessage(eventData[0], eventData[1])\r\n                            emitter._external.emit('error', error, orderNumber)\r\n                        } else {\r\n                            var emitArgs = [event]\r\n                            if(eventData !== undefined) emitArgs = emitArgs.concat(eventData)\r\n                            if(orderNumber !== undefined) emitArgs.push(orderNumber)\r\n                            emitter._external.emit.apply(emitter._external, emitArgs)\r\n\r\n                            if(event === 'end') {\r\n                                emitter.endMessageReceived = true\r\n                                if(emitter.endMessageSent) {\r\n                                    delete that.commandState[message[0]] // ensures that \"rpepIdNotFound\" will be returned if this stream continues to be communicated on\r\n                                    checkCleanClose(that)\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                } else if(info.f !== undefined) { // response\r\n                    var theResolver = info\r\n                    if(message.length === 3) { // error response\r\n                        theResolver.reject(createErrorFromMessage(message[1], message[2]))\r\n                    } else { // normal response\r\n                        theResolver.resolve(message[1])\r\n                    }\r\n\r\n                    delete that.commandState[message[0]]\r\n                    checkCleanClose(that)\r\n                } else {\r\n                    throw new Error(\"Shouldn't get here \"+JSON.stringify(info))\r\n                }\r\n            } else {\r\n                that.emit('error', createUnparsableCommandError(rawMessage))\r\n                if(that.sendCommandErrorInfo) {\r\n                    that.fire(\"error\", {message: \"invalidMessage\", rawMessage: rawMessage.slice(0,200)})\r\n                } else {\r\n                    that.fire(\"error\", {message: \"invalidMessage\"})\r\n                }\r\n            }\r\n        } catch(e) {\r\n            that.emit('error', e)\r\n        }\r\n    }\r\n})\r\n\r\n// sends an rpepInvalidId error fire-and-forget message if the id isn't valid\r\n// returns true if the id is valid, false otherwise\r\nfunction validateId(that, id) {\r\n    if(id > that.maxId) {\r\n        var reason = \"Id greater than \"\r\n        if(that.maxId === defaultMaxId) reason += \"2^53\"\r\n        else                            reason += that.maxId\r\n    } else if(that.server) {\r\n        if(id%2 !== 1) {\r\n            var reason = \"Id from client not odd\"\r\n        }\r\n    } else if(id%2 !== 0) {\r\n        var reason = \"Id from server not even\"\r\n    }\r\n\r\n    if(reason !== undefined) {\r\n        that.fire(\"error\", {message: 'rpepInvalidId', reason: reason})\r\n        return false\r\n    } else {\r\n        return true\r\n    }\r\n}\r\n\r\n\r\nvar RpepDuplexEventEmitter = proto(DuplexEventEmitter, function(superclass) {\r\n    this.on = function(event,handler) {\r\n        if(event in reservedEventListeningEvents)\r\n            throw new Error(\"Can't listen on the '\"+event+\"' event directly; the '\"+event+\"' event is reserved for internal use.\")\r\n\r\n        superclass.on.call(this, event,handler)\r\n    }\r\n\r\n    this.onAny = function(callback) {\r\n        superclass.onAny.call(this, function(eventName) {\r\n            if(!(eventName in reservedEventListeningEvents)) {\r\n                callback.apply(this, arguments)\r\n            }\r\n        }.bind(this))\r\n    }\r\n})\r\n\r\nfunction createUnparsableCommandError(rawMessage) {\r\n    var unparsableCommmandError = err(\"unparsableCommand\", \"'\"+rawMessage+\"'\")\r\n    unparsableCommmandError.name = 'UnparsableCommand'\r\n    return unparsableCommmandError\r\n}\r\n\r\nfunction err(code, message) {\r\n    var error = new Error(message || code)\r\n    error.code = code\r\n    return error\r\n}\n\n\n// WEBPACK FOOTER //\n// ./rpep.js(original)","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/process/browser.js\n// module id = 3\n// module chunks = 0","\r\n\r\nexports.resolver = function() {\r\n    var resolve, reject\r\n    var f = new Promise(function(inResolve, inReject) {\r\n        resolve = inResolve\r\n        reject = inReject\r\n    })\r\n\r\n    return {f: f, resolve:resolve, reject:reject}\r\n}\r\n\r\n// compares arrays and objects for value equality (all elements and members must match)\r\nexports.equal = function(a,b) {\r\n    if(a instanceof Array) {\r\n        if(!(b instanceof Array))\r\n            return false\r\n        if(a.length !== b.length) {\r\n            return false\r\n        } else {\r\n            for(var n=0; n<a.length; n++) {\r\n                if(!exports.equal(a[n],b[n])) {\r\n                    return false\r\n                }\r\n            }\r\n            // else\r\n            return true\r\n        }\r\n    } else if(a instanceof Object) {\r\n        if(!(b instanceof Object))\r\n            return false\r\n\r\n        var aKeys = getKeys(a)\r\n        var bKeys = getKeys(b)\r\n\r\n        if(aKeys.length !== bKeys.length) {\r\n            return false\r\n        } else {\r\n            for(var n=0; n<aKeys.length; n++) {\r\n                var key = aKeys[n]\r\n                var aVal = a[key]\r\n                var bVal = b[key]\r\n\r\n                if(!exports.equal(aVal,bVal)) {\r\n                    return false\r\n                }\r\n            }\r\n            // else\r\n            return true\r\n        }\r\n    } else {\r\n        return a===b || Number.isNaN(a) && Number.isNaN(b)\r\n    }\r\n}\r\n\r\n// counts object own-keys ignoring properties that are undefined\r\nfunction getKeys(x) {\r\n    var keys=[]\r\n    for(var k in x) {\r\n        if(x[k] !== undefined && Object.prototype.hasOwnProperty.call(x,k)) {\r\n            keys.push(k)\r\n        }\r\n    }\r\n\r\n    return keys\r\n}\n\n\n// WEBPACK FOOTER //\n// ./utils.js(original)","var proto = require(\"proto\")\nvar EventEmitter = require('eventemitter2')\n\n// an event emitter where listening to it listens to the other end and emitting emits to the other end\nmodule.exports = proto(function() {\n    this.init = function(onEmitHandler) {\n        this._external = new EventEmitter({newListener: false})\n        this._onEmitHandler = onEmitHandler\n    }\n\n    this.emit = function(event/*, arguments...*/) {\n        if(this.ended) throw new Error(\"Duplex Stream has already been ended.\")\n        this._onEmitHandler.apply(this._onEmitHandler, arguments)\n    }\n    this.on = function(event,handler) {\n        this._external.on(event,handler)\n    }\n    this.off = this.removeListener = function(event, handler) {\n        this._external.removeListener(event,handler)\n    }\n    this.onAny = function(handler) {\n        this._external.onAny(handler)\n    }\n    this.offAny = function(handler) {\n        this._external.offAny(handler)\n    }\n})\n\n\n// WEBPACK FOOTER //\n// ./DuplexEventEmitter.js(original)"],"sourceRoot":""}