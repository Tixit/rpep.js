{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 68f87f0bb8feefdc98b9","webpack:///./node_modules/eventemitter2/lib/eventemitter2.js","webpack:///./node_modules/proto/proto.js","webpack:///./rpep.js(original)","webpack:///./node_modules/process/browser.js","webpack:///./DuplexEventEmitter.js(original)"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;;+CC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,oDAAoD,YAAY;AAChE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,kDAAkD,uBAAuB;AACzE;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;;AAEA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2BAA2B;AAC3B,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,wCAAwC,iCAAiC;AACzE;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,4CAA4C;AAC5C,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;AACA;;AAEA;;AAEA,iDAAiD,YAAY;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AAAA;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;ACvwBD;AACA;;AAEA;;AAEA,kGAAkG,iBAAiB;AACnH;AACA;;AAEA;AACA,sBAAsB;AACtB;;AAEA,KAAK,OAAO;AACZ;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uDAAuD;AACvD;AACA,cAAc;AACd;AACA,KAAK;AACL;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA,+CAA+C;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;AACvC;;AAEA;AACA;;AAEA,0BAA0B;;AAE1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mEAAmE;AA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CA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;;;;;ACvLtC,IAAI,QAAQ,oBAAQ;AACpB,IAAI,eAAe,oBAAQ;AAG3B,OAAO,OAAP,GAAiB,MAAM,YAAW;IAC9B,KAAK,IAAL,GAAY,UAAS,eAAe;QAChC,KAAK,SAAL,GAAiB,IAAI,YAAJ;QACjB,KAAK,cAAL,GAAsB;IAC9B;IAEI,KAAK,IAAL,GAAY,UAAS,KAAO,QAAM;QAC9B,IAAG,KAAK;YAAO,MAAM,IAAI,KAAJ,CAAU;QAC/B,KAAK,cAAL,CAAoB,OAAM;IAClC;IACI,KAAK,EAAL,GAAU,UAAS,KAAM,WAAS;QAC9B,KAAK,SAAL,CAAe,EAAf,CAAkB,OAAM;IAChC;IACI,KAAK,GAAL,IAAW,KAAK,cAAL,GAAsB,UAAS,KAAO,WAAS;QACtD,KAAK,SAAL,CAAe,cAAf,CAA8B,OAAM;IAC5C;IACI,KAAK,KAAL,GAAa,UAAS,SAAS;QAC3B,KAAK,SAAL,CAAe,KAAf,CAAqB;IAC7B;IAEI,KAAK,GAAL,GAAW,YAAW;QAClB,KAAK,IAAL,CAAU;QACV,KAAK,KAAL,GAAa;IACrB;AACA;AA5BA","file":"rpep-dev.umd.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"rpep\"] = factory();\n\telse\n\t\troot[\"rpep\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 68f87f0bb8feefdc98b9","/*!\r\n * EventEmitter2\r\n * https://github.com/hij1nx/EventEmitter2\r\n *\r\n * Copyright (c) 2013 hij1nx\r\n * Licensed under the MIT license.\r\n */\r\n;!function(undefined) {\r\n\r\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\r\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\r\n  };\r\n  var defaultMaxListeners = 10;\r\n\r\n  function init() {\r\n    this._events = {};\r\n    if (this._conf) {\r\n      configure.call(this, this._conf);\r\n    }\r\n  }\r\n\r\n  function configure(conf) {\r\n    if (conf) {\r\n      this._conf = conf;\r\n\r\n      conf.delimiter && (this.delimiter = conf.delimiter);\r\n      this._maxListeners = conf.maxListeners !== undefined ? conf.maxListeners : defaultMaxListeners;\r\n\r\n      conf.wildcard && (this.wildcard = conf.wildcard);\r\n      conf.newListener && (this.newListener = conf.newListener);\r\n      conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);\r\n\r\n      if (this.wildcard) {\r\n        this.listenerTree = {};\r\n      }\r\n    } else {\r\n      this._maxListeners = defaultMaxListeners;\r\n    }\r\n  }\r\n\r\n  function logPossibleMemoryLeak(count, eventName) {\r\n    var errorMsg = '(node) warning: possible EventEmitter memory ' +\r\n        'leak detected. ' + count + ' listeners added. ' +\r\n        'Use emitter.setMaxListeners() to increase limit.';\r\n\r\n    if(this.verboseMemoryLeak){\r\n      errorMsg += ' Event name: ' + eventName + '.';\r\n    }\r\n\r\n    if(typeof process !== 'undefined' && process.emitWarning){\r\n      var e = new Error(errorMsg);\r\n      e.name = 'MaxListenersExceededWarning';\r\n      e.emitter = this;\r\n      e.count = count;\r\n      process.emitWarning(e);\r\n    } else {\r\n      console.error(errorMsg);\r\n\r\n      if (console.trace){\r\n        console.trace();\r\n      }\r\n    }\r\n  }\r\n\r\n  function EventEmitter(conf) {\r\n    this._events = {};\r\n    this.newListener = false;\r\n    this.verboseMemoryLeak = false;\r\n    configure.call(this, conf);\r\n  }\r\n  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property\r\n\r\n  //\r\n  // Attention, function return type now is array, always !\r\n  // It has zero elements if no any matches found and one or more\r\n  // elements (leafs) if there are matches\r\n  //\r\n  function searchListenerTree(handlers, type, tree, i) {\r\n    if (!tree) {\r\n      return [];\r\n    }\r\n    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,\r\n        typeLength = type.length, currentType = type[i], nextType = type[i+1];\r\n    if (i === typeLength && tree._listeners) {\r\n      //\r\n      // If at the end of the event(s) list and the tree has listeners\r\n      // invoke those listeners.\r\n      //\r\n      if (typeof tree._listeners === 'function') {\r\n        handlers && handlers.push(tree._listeners);\r\n        return [tree];\r\n      } else {\r\n        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\r\n          handlers && handlers.push(tree._listeners[leaf]);\r\n        }\r\n        return [tree];\r\n      }\r\n    }\r\n\r\n    if ((currentType === '*' || currentType === '**') || tree[currentType]) {\r\n      //\r\n      // If the event emitted is '*' at this part\r\n      // or there is a concrete match at this patch\r\n      //\r\n      if (currentType === '*') {\r\n        for (branch in tree) {\r\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\r\n            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));\r\n          }\r\n        }\r\n        return listeners;\r\n      } else if(currentType === '**') {\r\n        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));\r\n        if(endReached && tree._listeners) {\r\n          // The next element has a _listeners, add it to the handlers.\r\n          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\r\n        }\r\n\r\n        for (branch in tree) {\r\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\r\n            if(branch === '*' || branch === '**') {\r\n              if(tree[branch]._listeners && !endReached) {\r\n                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\r\n              }\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\r\n            } else if(branch === nextType) {\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));\r\n            } else {\r\n              // No match on this one, shift into the tree but not in the type array.\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\r\n            }\r\n          }\r\n        }\r\n        return listeners;\r\n      }\r\n\r\n      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));\r\n    }\r\n\r\n    xTree = tree['*'];\r\n    if (xTree) {\r\n      //\r\n      // If the listener tree will allow any match for this part,\r\n      // then recursively explore all branches of the tree\r\n      //\r\n      searchListenerTree(handlers, type, xTree, i+1);\r\n    }\r\n\r\n    xxTree = tree['**'];\r\n    if(xxTree) {\r\n      if(i < typeLength) {\r\n        if(xxTree._listeners) {\r\n          // If we have a listener on a '**', it will catch all, so add its handler.\r\n          searchListenerTree(handlers, type, xxTree, typeLength);\r\n        }\r\n\r\n        // Build arrays of matching next branches and others.\r\n        for(branch in xxTree) {\r\n          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\r\n            if(branch === nextType) {\r\n              // We know the next element will match, so jump twice.\r\n              searchListenerTree(handlers, type, xxTree[branch], i+2);\r\n            } else if(branch === currentType) {\r\n              // Current node matches, move into the tree.\r\n              searchListenerTree(handlers, type, xxTree[branch], i+1);\r\n            } else {\r\n              isolatedBranch = {};\r\n              isolatedBranch[branch] = xxTree[branch];\r\n              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);\r\n            }\r\n          }\r\n        }\r\n      } else if(xxTree._listeners) {\r\n        // We have reached the end and still on a '**'\r\n        searchListenerTree(handlers, type, xxTree, typeLength);\r\n      } else if(xxTree['*'] && xxTree['*']._listeners) {\r\n        searchListenerTree(handlers, type, xxTree['*'], typeLength);\r\n      }\r\n    }\r\n\r\n    return listeners;\r\n  }\r\n\r\n  function growListenerTree(type, listener) {\r\n\r\n    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n\r\n    //\r\n    // Looks for two consecutive '**', if so, don't add the event at all.\r\n    //\r\n    for(var i = 0, len = type.length; i+1 < len; i++) {\r\n      if(type[i] === '**' && type[i+1] === '**') {\r\n        return;\r\n      }\r\n    }\r\n\r\n    var tree = this.listenerTree;\r\n    var name = type.shift();\r\n\r\n    while (name !== undefined) {\r\n\r\n      if (!tree[name]) {\r\n        tree[name] = {};\r\n      }\r\n\r\n      tree = tree[name];\r\n\r\n      if (type.length === 0) {\r\n\r\n        if (!tree._listeners) {\r\n          tree._listeners = listener;\r\n        }\r\n        else {\r\n          if (typeof tree._listeners === 'function') {\r\n            tree._listeners = [tree._listeners];\r\n          }\r\n\r\n          tree._listeners.push(listener);\r\n\r\n          if (\r\n            !tree._listeners.warned &&\r\n            this._maxListeners > 0 &&\r\n            tree._listeners.length > this._maxListeners\r\n          ) {\r\n            tree._listeners.warned = true;\r\n            logPossibleMemoryLeak.call(this, tree._listeners.length, name);\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n      name = type.shift();\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // By default EventEmitters will print a warning if more than\r\n  // 10 listeners are added to it. This is a useful default which\r\n  // helps finding memory leaks.\r\n  //\r\n  // Obviously not all Emitters should be limited to 10. This function allows\r\n  // that to be increased. Set to zero for unlimited.\r\n\r\n  EventEmitter.prototype.delimiter = '.';\r\n\r\n  EventEmitter.prototype.setMaxListeners = function(n) {\r\n    if (n !== undefined) {\r\n      this._maxListeners = n;\r\n      if (!this._conf) this._conf = {};\r\n      this._conf.maxListeners = n;\r\n    }\r\n  };\r\n\r\n  EventEmitter.prototype.event = '';\r\n\r\n\r\n  EventEmitter.prototype.once = function(event, fn) {\r\n    return this._once(event, fn, false);\r\n  };\r\n\r\n  EventEmitter.prototype.prependOnceListener = function(event, fn) {\r\n    return this._once(event, fn, true);\r\n  };\r\n\r\n  EventEmitter.prototype._once = function(event, fn, prepend) {\r\n    this._many(event, 1, fn, prepend);\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.many = function(event, ttl, fn) {\r\n    return this._many(event, ttl, fn, false);\r\n  }\r\n\r\n  EventEmitter.prototype.prependMany = function(event, ttl, fn) {\r\n    return this._many(event, ttl, fn, true);\r\n  }\r\n\r\n  EventEmitter.prototype._many = function(event, ttl, fn, prepend) {\r\n    var self = this;\r\n\r\n    if (typeof fn !== 'function') {\r\n      throw new Error('many only accepts instances of Function');\r\n    }\r\n\r\n    function listener() {\r\n      if (--ttl === 0) {\r\n        self.off(event, listener);\r\n      }\r\n      return fn.apply(this, arguments);\r\n    }\r\n\r\n    listener._origin = fn;\r\n\r\n    this._on(event, listener, prepend);\r\n\r\n    return self;\r\n  };\r\n\r\n  EventEmitter.prototype.emit = function() {\r\n\r\n    this._events || init.call(this);\r\n\r\n    var type = arguments[0];\r\n\r\n    if (type === 'newListener' && !this.newListener) {\r\n      if (!this._events.newListener) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    var al = arguments.length;\r\n    var args,l,i,j;\r\n    var handler;\r\n\r\n    if (this._all && this._all.length) {\r\n      handler = this._all.slice();\r\n      if (al > 3) {\r\n        args = new Array(al);\r\n        for (j = 0; j < al; j++) args[j] = arguments[j];\r\n      }\r\n\r\n      for (i = 0, l = handler.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          handler[i].call(this, type);\r\n          break;\r\n        case 2:\r\n          handler[i].call(this, type, arguments[1]);\r\n          break;\r\n        case 3:\r\n          handler[i].call(this, type, arguments[1], arguments[2]);\r\n          break;\r\n        default:\r\n          handler[i].apply(this, args);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.wildcard) {\r\n      handler = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\r\n    } else {\r\n      handler = this._events[type];\r\n      if (typeof handler === 'function') {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          handler.call(this);\r\n          break;\r\n        case 2:\r\n          handler.call(this, arguments[1]);\r\n          break;\r\n        case 3:\r\n          handler.call(this, arguments[1], arguments[2]);\r\n          break;\r\n        default:\r\n          args = new Array(al - 1);\r\n          for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n          handler.apply(this, args);\r\n        }\r\n        return true;\r\n      } else if (handler) {\r\n        // need to make copy of handlers because list can change in the middle\r\n        // of emit call\r\n        handler = handler.slice();\r\n      }\r\n    }\r\n\r\n    if (handler && handler.length) {\r\n      if (al > 3) {\r\n        args = new Array(al - 1);\r\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n      }\r\n      for (i = 0, l = handler.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          handler[i].call(this);\r\n          break;\r\n        case 2:\r\n          handler[i].call(this, arguments[1]);\r\n          break;\r\n        case 3:\r\n          handler[i].call(this, arguments[1], arguments[2]);\r\n          break;\r\n        default:\r\n          handler[i].apply(this, args);\r\n        }\r\n      }\r\n      return true;\r\n    } else if (!this._all && type === 'error') {\r\n      if (arguments[1] instanceof Error) {\r\n        throw arguments[1]; // Unhandled 'error' event\r\n      } else {\r\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\r\n      }\r\n      return false;\r\n    }\r\n\r\n    return !!this._all;\r\n  };\r\n\r\n  EventEmitter.prototype.emitAsync = function() {\r\n\r\n    this._events || init.call(this);\r\n\r\n    var type = arguments[0];\r\n\r\n    if (type === 'newListener' && !this.newListener) {\r\n        if (!this._events.newListener) { return Promise.resolve([false]); }\r\n    }\r\n\r\n    var promises= [];\r\n\r\n    var al = arguments.length;\r\n    var args,l,i,j;\r\n    var handler;\r\n\r\n    if (this._all) {\r\n      if (al > 3) {\r\n        args = new Array(al);\r\n        for (j = 1; j < al; j++) args[j] = arguments[j];\r\n      }\r\n      for (i = 0, l = this._all.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          promises.push(this._all[i].call(this, type));\r\n          break;\r\n        case 2:\r\n          promises.push(this._all[i].call(this, type, arguments[1]));\r\n          break;\r\n        case 3:\r\n          promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));\r\n          break;\r\n        default:\r\n          promises.push(this._all[i].apply(this, args));\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.wildcard) {\r\n      handler = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\r\n    } else {\r\n      handler = this._events[type];\r\n    }\r\n\r\n    if (typeof handler === 'function') {\r\n      this.event = type;\r\n      switch (al) {\r\n      case 1:\r\n        promises.push(handler.call(this));\r\n        break;\r\n      case 2:\r\n        promises.push(handler.call(this, arguments[1]));\r\n        break;\r\n      case 3:\r\n        promises.push(handler.call(this, arguments[1], arguments[2]));\r\n        break;\r\n      default:\r\n        args = new Array(al - 1);\r\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n        promises.push(handler.apply(this, args));\r\n      }\r\n    } else if (handler && handler.length) {\r\n      handler = handler.slice();\r\n      if (al > 3) {\r\n        args = new Array(al - 1);\r\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n      }\r\n      for (i = 0, l = handler.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          promises.push(handler[i].call(this));\r\n          break;\r\n        case 2:\r\n          promises.push(handler[i].call(this, arguments[1]));\r\n          break;\r\n        case 3:\r\n          promises.push(handler[i].call(this, arguments[1], arguments[2]));\r\n          break;\r\n        default:\r\n          promises.push(handler[i].apply(this, args));\r\n        }\r\n      }\r\n    } else if (!this._all && type === 'error') {\r\n      if (arguments[1] instanceof Error) {\r\n        return Promise.reject(arguments[1]); // Unhandled 'error' event\r\n      } else {\r\n        return Promise.reject(\"Uncaught, unspecified 'error' event.\");\r\n      }\r\n    }\r\n\r\n    return Promise.all(promises);\r\n  };\r\n\r\n  EventEmitter.prototype.on = function(type, listener) {\r\n    return this._on(type, listener, false);\r\n  };\r\n\r\n  EventEmitter.prototype.prependListener = function(type, listener) {\r\n    return this._on(type, listener, true);\r\n  };\r\n\r\n  EventEmitter.prototype.onAny = function(fn) {\r\n    return this._onAny(fn, false);\r\n  };\r\n\r\n  EventEmitter.prototype.prependAny = function(fn) {\r\n    return this._onAny(fn, true);\r\n  };\r\n\r\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\r\n\r\n  EventEmitter.prototype._onAny = function(fn, prepend){\r\n    if (typeof fn !== 'function') {\r\n      throw new Error('onAny only accepts instances of Function');\r\n    }\r\n\r\n    if (!this._all) {\r\n      this._all = [];\r\n    }\r\n\r\n    // Add the function to the event listener collection.\r\n    if(prepend){\r\n      this._all.unshift(fn);\r\n    }else{\r\n      this._all.push(fn);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  EventEmitter.prototype._on = function(type, listener, prepend) {\r\n    if (typeof type === 'function') {\r\n      this._onAny(type, listener);\r\n      return this;\r\n    }\r\n\r\n    if (typeof listener !== 'function') {\r\n      throw new Error('on only accepts instances of Function');\r\n    }\r\n    this._events || init.call(this);\r\n\r\n    // To avoid recursion in the case that type == \"newListeners\"! Before\r\n    // adding it to the listeners, first emit \"newListeners\".\r\n    this.emit('newListener', type, listener);\r\n\r\n    if (this.wildcard) {\r\n      growListenerTree.call(this, type, listener);\r\n      return this;\r\n    }\r\n\r\n    if (!this._events[type]) {\r\n      // Optimize the case of one listener. Don't need the extra array object.\r\n      this._events[type] = listener;\r\n    }\r\n    else {\r\n      if (typeof this._events[type] === 'function') {\r\n        // Change to array.\r\n        this._events[type] = [this._events[type]];\r\n      }\r\n\r\n      // If we've already got an array, just add\r\n      if(prepend){\r\n        this._events[type].unshift(listener);\r\n      }else{\r\n        this._events[type].push(listener);\r\n      }\r\n\r\n      // Check for listener leak\r\n      if (\r\n        !this._events[type].warned &&\r\n        this._maxListeners > 0 &&\r\n        this._events[type].length > this._maxListeners\r\n      ) {\r\n        this._events[type].warned = true;\r\n        logPossibleMemoryLeak.call(this, this._events[type].length, type);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  EventEmitter.prototype.off = function(type, listener) {\r\n    if (typeof listener !== 'function') {\r\n      throw new Error('removeListener only takes instances of Function');\r\n    }\r\n\r\n    var handlers,leafs=[];\r\n\r\n    if(this.wildcard) {\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\r\n    }\r\n    else {\r\n      // does not use listeners(), so no side effect of creating _events[type]\r\n      if (!this._events[type]) return this;\r\n      handlers = this._events[type];\r\n      leafs.push({_listeners:handlers});\r\n    }\r\n\r\n    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\r\n      var leaf = leafs[iLeaf];\r\n      handlers = leaf._listeners;\r\n      if (isArray(handlers)) {\r\n\r\n        var position = -1;\r\n\r\n        for (var i = 0, length = handlers.length; i < length; i++) {\r\n          if (handlers[i] === listener ||\r\n            (handlers[i].listener && handlers[i].listener === listener) ||\r\n            (handlers[i]._origin && handlers[i]._origin === listener)) {\r\n            position = i;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (position < 0) {\r\n          continue;\r\n        }\r\n\r\n        if(this.wildcard) {\r\n          leaf._listeners.splice(position, 1);\r\n        }\r\n        else {\r\n          this._events[type].splice(position, 1);\r\n        }\r\n\r\n        if (handlers.length === 0) {\r\n          if(this.wildcard) {\r\n            delete leaf._listeners;\r\n          }\r\n          else {\r\n            delete this._events[type];\r\n          }\r\n        }\r\n\r\n        this.emit(\"removeListener\", type, listener);\r\n\r\n        return this;\r\n      }\r\n      else if (handlers === listener ||\r\n        (handlers.listener && handlers.listener === listener) ||\r\n        (handlers._origin && handlers._origin === listener)) {\r\n        if(this.wildcard) {\r\n          delete leaf._listeners;\r\n        }\r\n        else {\r\n          delete this._events[type];\r\n        }\r\n\r\n        this.emit(\"removeListener\", type, listener);\r\n      }\r\n    }\r\n\r\n    function recursivelyGarbageCollect(root) {\r\n      if (root === undefined) {\r\n        return;\r\n      }\r\n      var keys = Object.keys(root);\r\n      for (var i in keys) {\r\n        var key = keys[i];\r\n        var obj = root[key];\r\n        if ((obj instanceof Function) || (typeof obj !== \"object\") || (obj === null))\r\n          continue;\r\n        if (Object.keys(obj).length > 0) {\r\n          recursivelyGarbageCollect(root[key]);\r\n        }\r\n        if (Object.keys(obj).length === 0) {\r\n          delete root[key];\r\n        }\r\n      }\r\n    }\r\n    recursivelyGarbageCollect(this.listenerTree);\r\n\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.offAny = function(fn) {\r\n    var i = 0, l = 0, fns;\r\n    if (fn && this._all && this._all.length > 0) {\r\n      fns = this._all;\r\n      for(i = 0, l = fns.length; i < l; i++) {\r\n        if(fn === fns[i]) {\r\n          fns.splice(i, 1);\r\n          this.emit(\"removeListenerAny\", fn);\r\n          return this;\r\n        }\r\n      }\r\n    } else {\r\n      fns = this._all;\r\n      for(i = 0, l = fns.length; i < l; i++)\r\n        this.emit(\"removeListenerAny\", fns[i]);\r\n      this._all = [];\r\n    }\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\r\n\r\n  EventEmitter.prototype.removeAllListeners = function(type) {\r\n    if (arguments.length === 0) {\r\n      !this._events || init.call(this);\r\n      return this;\r\n    }\r\n\r\n    if (this.wildcard) {\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\r\n\r\n      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\r\n        var leaf = leafs[iLeaf];\r\n        leaf._listeners = null;\r\n      }\r\n    }\r\n    else if (this._events) {\r\n      this._events[type] = null;\r\n    }\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.listeners = function(type) {\r\n    if (this.wildcard) {\r\n      var handlers = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\r\n      return handlers;\r\n    }\r\n\r\n    this._events || init.call(this);\r\n\r\n    if (!this._events[type]) this._events[type] = [];\r\n    if (!isArray(this._events[type])) {\r\n      this._events[type] = [this._events[type]];\r\n    }\r\n    return this._events[type];\r\n  };\r\n\r\n  EventEmitter.prototype.eventNames = function(){\r\n    return Object.keys(this._events);\r\n  }\r\n\r\n  EventEmitter.prototype.listenerCount = function(type) {\r\n    return this.listeners(type).length;\r\n  };\r\n\r\n  EventEmitter.prototype.listenersAny = function() {\r\n\r\n    if(this._all) {\r\n      return this._all;\r\n    }\r\n    else {\r\n      return [];\r\n    }\r\n\r\n  };\r\n\r\n  if (typeof define === 'function' && define.amd) {\r\n     // AMD. Register as an anonymous module.\r\n    define(function() {\r\n      return EventEmitter;\r\n    });\r\n  } else if (typeof exports === 'object') {\r\n    // CommonJS\r\n    module.exports = EventEmitter;\r\n  }\r\n  else {\r\n    // Browser global.\r\n    window.EventEmitter2 = EventEmitter;\r\n  }\r\n}();\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/eventemitter2/lib/eventemitter2.js\n// module id = 0\n// module chunks = 0","\"use strict\";\r\n/* Copyright (c) 2013 Billy Tetrud - Free to use for any purpose: MIT License*/\r\n\r\nvar noop = function() {}\r\n\r\nvar prototypeName='prototype', undefined, protoUndefined='undefined', init='init', ownProperty=({}).hasOwnProperty; // minifiable variables\r\nfunction proto() {\r\n    var args = arguments // minifiable variables\r\n\r\n    if(args.length == 1) {\r\n        var parent = {init: noop}\r\n        var prototypeBuilder = args[0]\r\n\r\n    } else { // length == 2\r\n        var parent = args[0]\r\n        var prototypeBuilder = args[1]\r\n    }\r\n\r\n    // special handling for Error objects\r\n    var namePointer = {}    // name used only for Error Objects\r\n    if([Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError].indexOf(parent) !== -1) {\r\n        parent = normalizeErrorObject(parent, namePointer)\r\n    }\r\n\r\n    // set up the parent into the prototype chain if a parent is passed\r\n    var parentIsFunction = typeof(parent) === \"function\"\r\n    if(parentIsFunction) {\r\n        prototypeBuilder[prototypeName] = parent[prototypeName]\r\n    } else {\r\n        prototypeBuilder[prototypeName] = parent\r\n    }\r\n\r\n    // the prototype that will be used to make instances\r\n    var prototype = new prototypeBuilder(parent)\r\n    namePointer.name = prototype.name\r\n\r\n    // if there's no init, assume its inheriting a non-proto class, so default to applying the superclass's constructor.\r\n    if(!prototype[init] && parentIsFunction) {\r\n        prototype[init] = function() {\r\n            parent.apply(this, arguments)\r\n        }\r\n    }\r\n\r\n    // constructor for empty object which will be populated via the constructor\r\n    var F = function() {}\r\n        F[prototypeName] = prototype    // set the prototype for created instances\r\n\r\n    var constructorName = prototype.name?prototype.name:''\r\n    if(prototype[init] === undefined || prototype[init] === noop) {\r\n        var ProtoObjectFactory = new Function('F',\r\n            \"return function \" + constructorName + \"(){\" +\r\n                \"return new F()\" +\r\n            \"}\"\r\n        )(F)\r\n    } else {\r\n        // dynamically creating this function cause there's no other way to dynamically name a function\r\n        var ProtoObjectFactory = new Function('F','i','u','n', // shitty variables cause minifiers aren't gonna minify my function string here\r\n            \"return function \" + constructorName + \"(){ \" +\r\n                \"var x=new F(),r=i.apply(x,arguments)\\n\" +    // populate object via the constructor\r\n                \"if(r===n)\\n\" +\r\n                    \"return x\\n\" +\r\n                \"else if(r===u)\\n\" +\r\n                    \"return n\\n\" +\r\n                \"else\\n\" +\r\n                    \"return r\\n\" +\r\n            \"}\"\r\n        )(F, prototype[init], proto[protoUndefined]) // note that n is undefined\r\n    }\r\n\r\n    prototype.constructor = ProtoObjectFactory;    // set the constructor property on the prototype\r\n\r\n    // add all the prototype properties onto the static class as well (so you can access that class when you want to reference superclass properties)\r\n    for(var n in prototype) {\r\n        addProperty(ProtoObjectFactory, prototype, n)\r\n    }\r\n\r\n    // add properties from parent that don't exist in the static class object yet\r\n    for(var n in parent) {\r\n        if(ownProperty.call(parent, n) && ProtoObjectFactory[n] === undefined) {\r\n            addProperty(ProtoObjectFactory, parent, n)\r\n        }\r\n    }\r\n\r\n    ProtoObjectFactory.parent = parent;            // special parent property only available on the returned proto class\r\n    ProtoObjectFactory[prototypeName] = prototype  // set the prototype on the object factory\r\n\r\n    return ProtoObjectFactory;\r\n}\r\n\r\nproto[protoUndefined] = {} // a special marker for when you want to return undefined from a constructor\r\n\r\nmodule.exports = proto\r\n\r\nfunction normalizeErrorObject(ErrorObject, namePointer) {\r\n    function NormalizedError() {\r\n        var tmp = new ErrorObject(arguments[0])\r\n        tmp.name = namePointer.name\r\n\r\n        this.message = tmp.message\r\n        if(Object.defineProperty) {\r\n            /*this.stack = */Object.defineProperty(this, 'stack', { // getter for more optimizy goodness\r\n                get: function() {\r\n                    return tmp.stack\r\n                },\r\n                configurable: true // so you can change it if you want\r\n            })\r\n        } else {\r\n            this.stack = tmp.stack\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    var IntermediateInheritor = function() {}\r\n        IntermediateInheritor.prototype = ErrorObject.prototype\r\n    NormalizedError.prototype = new IntermediateInheritor()\r\n\r\n    return NormalizedError\r\n}\r\n\r\nfunction addProperty(factoryObject, prototype, property) {\r\n    try {\r\n        var info = Object.getOwnPropertyDescriptor(prototype, property)\r\n        if(info.get !== undefined || info.get !== undefined && Object.defineProperty !== undefined) {\r\n            Object.defineProperty(factoryObject, property, info)\r\n        } else {\r\n            factoryObject[property] = prototype[property]\r\n        }\r\n    } catch(e) {\r\n        // do nothing, if a property (like `name`) can't be set, just ignore it\r\n    }\r\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/proto/proto.js\n// module id = 1\n// module chunks = 0","var EventEmitter = require('eventemitter2')\r\nvar proto = require(\"proto\")\r\n\r\nvar DuplexEventEmitter = require('./DuplexEventEmitter')\r\n\r\n// enums\r\nvar receive = 0\r\nvar respond = 0\r\nvar stream = 0\r\n\r\nvar maxId = 9007199254740992 // 2^53]\r\nvar reservedSendingCommands = {close:1,idDiscontinuity:1, e:1,error:1}\r\nvar reservedListeningCommands = {close:1,idDiscontinuity:1}\r\nvar reservedListeningErrorCommands = {e:1,error:1}\r\nvar reservedEventListeningEvents = {order:1}\r\nvar reservedStreamEmissionEvents = {e:1,orderNumberDiscontinuity:1}\r\n\r\n\r\nvar buffer = 50 // some buffer for message header stuff\r\n\r\nvar PeerError = proto(Error, function() {\r\n    this.name = \"PeerError\"\r\n})\r\n\r\n// An instance of RpepCore can emit the following events:\r\n    // 'close' - Fired once the listening serverhas been closed\r\n    // 'error'\r\nmodule.exports = proto(function() {\r\n\r\n    // static properties\r\n\r\n    // an error that, when thrown, sends the error as an error response to the other Peer (including iterable properties, but not including the stack)\r\n    this.PeerError = PeerError\r\n\r\n    // instance properties\r\n\r\n    // transport is an object with the following methods:\r\n        // connect(/*transport connect parameters... */, rpepOptions) - connects to a websocket server\r\n            // transport connect parameters... - A variable number of transport connect parameters passed into rpepPeer.connect\r\n            // rpepOptions - An object containing the maxSendSize and maxReceiveSize options\r\n            // returns a connection object\r\n               // with the following methods:\r\n                // send(message)\r\n                // close() - Closes the connection in a way that actively informs the other Peer about closure.\r\n                // drop() - (Optional) Closes the connection without informing the other Peer.\r\n               // and the following event-handler functions (which will only be called once):\r\n                // onOpen(callback)\r\n                // onClose(callback) - (Optional) Must be fired even if an error event has happened, or the connection will be assumed to still be open. If not given, a \"close\" fire-and-forget message will be sent before connection closure if the Peer is a server, and that \"close\" message will be listened for if its a client Peer.\r\n                // onMessage(callback)\r\n                // onError(callback)\r\n        // listen(/*transport listen parameters... */, rpepOptions, callback) - (Optional) Listens for connectiosn and calls `callback` when a connection comes through.\r\n            // transport listen parameters... - A variable number of transport listen parameters passed into rpepPeer.listen\r\n            // Parameters:\r\n                // rpepOptions - An object containing the maxSendSize and maxReceiveSize options\r\n                // callback(request) - Called when a connection request comes through.\r\n                    // `request` has the methods:\r\n                        // accept() - Returns a connection object (with the same API as the object that `connect` returns).\r\n                        // reject()\r\n                    // and the following property:\r\n                        // rawRequest - The raw request from the transport\r\n            // returns an object\r\n               // with the following method:\r\n                // close() - closes the listening server\r\n               // and the following event-handler functions (which will only be called once):\r\n                // onListening(callback) - Called when the server starts listening\r\n                // onClose(callback) - Called when the server stops listening\r\n                // onError(callback) - Called if listening couldn't be started\r\n    // serialization is an object with the following methods:\r\n        // serialize(javascriptObject) - Returns the javascript object in serialized form (something the transport can process, most likely a string or Buffer)\r\n        // deserialize(serializedObject) - Returns a javascript object reprented by the serializedObject\r\n    // options:\r\n        // maxSendSize - The maximum byte-length a sent message can be (Default: no limit)\r\n        // maxReceiveSize - The maximum byte-length a received message can be (Default: no limit)\r\n        // sendCommandErrorInfo - (Default:true)\r\n            // If true,\r\n                // errors will automatically be sent to the other Peer if their command is unparsable, and\r\n                // the first part of the command will be sent with an \"invalidMessage\" error\r\n            // Otherwise, the error will be ignored (but handleable via rawHandle or preHandle, depending on the case).\r\n    this.init = function(transport, serialization, options) {\r\n        if(!options) options = {}\r\n\r\n        this.transport = transport\r\n        this.serialization = serialization\r\n        this.options = options\r\n\r\n        this.commands = {}\r\n        // this.listener\r\n    }\r\n\r\n    // returns a future open connection\r\n    // options - an object with transport-specific options\r\n    this.connect = function() {\r\n        var args = Array.prototype.slice.call(arguments)\r\n\r\n        var that = this\r\n        return new Promise(function(resolve, reject) {\r\n            var connection = this.transport.connect.apply(this.transport.connect, args.concat([that.options]))\r\n\r\n            var onOpenCalled = false, errors = []\r\n            connection.onOpen(function() {\r\n                onOpenCalled = true\r\n                resolve(rpepConn)\r\n            })\r\n\r\n            var rpepConn = RpepConnection(that, connection)\r\n\r\n            connection.onError(function(e) {\r\n                errors.push(e)\r\n            })\r\n\r\n            if(connection.onClose) {\r\n                connection.onClose(function() {\r\n                    if(!onOpenCalled) {\r\n                        var message = \"Connection couldn't be opened\"\r\n                        if(errors.length > 0) {\r\n                            message+': \\n'+errors.join('\\n')\r\n                        }\r\n\r\n                        var e = new Error(message)\r\n                        e.errors = errors\r\n                        reject(e)\r\n                    }\r\n                })\r\n            }\r\n        })\r\n    }\r\n\r\n    // returns a future that resolves successfully when the server has begun listening and resolves to an error if listening couldn't be started\r\n    this.listen = function(/*variable number of listen parameters, requestHandler*/) {\r\n        var args = Array.prototype.slice.call(arguments)\r\n        var requestHandler = args[args.length-1]\r\n        var transportListenArguments = args.slice(0,-1)\r\n\r\n        var that = this\r\n        return new Promise(function(resolve, reject) {\r\n            if(that.listener !== undefined) {\r\n                throw new Error(\"Rpep object already listening!\")\r\n            }\r\n\r\n            var that = this\r\n            that.listener = this.transport.listen(port, that.options, function(request) {\r\n                requestHandler(request, {\r\n                    accept: function() {\r\n                        var connection = request.accept()\r\n                        return RpepConnection(that, connection)\r\n                    },\r\n                    reject: function() {\r\n                        request.reject()\r\n                    },\r\n                    rawRequest: request\r\n                })\r\n            })\r\n\r\n            that.listener.onListening(function() {\r\n                resolve()\r\n            })\r\n            that.listener.onError(function(e) {\r\n                reject(e)\r\n            })\r\n            that.listener.onClose(function(e) {\r\n                that.listener = undefined\r\n            })\r\n        })\r\n    }\r\n\r\n    /*this.listening = */Object.defineProperty(this, 'listening', {\r\n        get: function() {\r\n            this.listener !== undefined\r\n        }\r\n    })\r\n\r\n    // closes a listening websocket server\r\n    // no-op if the server is already closed\r\n    this.close = function() {\r\n        if(this.listener)\r\n            this.listener.close()\r\n    }\r\n\r\n    // sets up a handler to receive a fireAndForget call\r\n    this.receive = function(command, handler) {\r\n        addCommand(that, receive, command, handler)\r\n    }\r\n\r\n    // sets up a handler to handle request-response calls\r\n    // the handler can either return\r\n        // A (possibly future) value, which will be sent as a response. Or,\r\n        // A (possibly future) Error object. The 'message' will be sent as the `error`, and any other iterable properties of the object will be added as the `data`.\r\n    this.respond = function(command, handler) {\r\n        addCommand(that, respond, command, handler)\r\n    }\r\n\r\n    // sets up a handler to handle event-steam calls\r\n    this.stream = function(command, handler) {\r\n        addCommand(that, stream, command, handler)\r\n    }\r\n\r\n    // Sets a default command handler\r\n    this.default = function(handler) {\r\n        if(this.defaultHandler !== undefined)\r\n            throw handlerError('default handler')\r\n\r\n        this.defaultHandler = handler\r\n    }\r\n\r\n    // Sets up a function that is run before every command\r\n    // If \"ignore\" is returned from `handler`, the corresponding receive, respond, stream, or default handler will not be called\r\n    this.preHandle = function(handler) {\r\n        if(this.preHandler !== undefined)\r\n            throw handlerError('preHandle')\r\n\r\n        this.preHandler = handler\r\n    }\r\n\r\n    // Sets up a function that is run before the command is even parsed\r\n    // If \"ignore\" is returned from `handler`, preHandle and the corresponding receive, respond, stream, or default handler will not be called\r\n    this.rawHandle = function(handler) {\r\n        if(this.rawHandler !== undefined)\r\n            throw handlerError('rawHandle')\r\n\r\n        this.rawHandler = handler\r\n    }\r\n\r\n    // private\r\n\r\n    function addCommand(that, type, command, handler) {\r\n        if(this.commands[command] !== undefined)\r\n            throw handlerError('handler for \"'+command+'\"')\r\n        if(command in reservedFireAndForgetErrorCommands)\r\n            throw new Error(\"Can't setup a handler for the command '\"+command+\"', because it's reserved for global error messages. To handle global errors, listen to the connection's 'error' event.\")\r\n        if(command in reservedFireAndForgetCommands)\r\n            throw new Error(\"Can't setup a handler for the command '\"+command+\"', because it's reserved for internal use.\")\r\n\r\n        this.commands[command] = {type: type, handler: handler}\r\n    }\r\n\r\n    function handlerError(handlerName) {\r\n        return new Error('A '+handlerName+' already exists! You can only have one handler per command.')\r\n    }\r\n})\r\n\r\n// An instance of RpepCore can emit the following events:\r\n    // close() - Fired once the connection has been closed\r\n    // error(e)\r\n    // openMessage() - Fired when an 'open' message is received. For internal use only.\r\n    // closeMessage() - Fired when a 'close' message is received. For internal use only.\r\nvar RpepConnection = proto(EventEmitter, function() {\r\n\r\n    // options\r\n        // server - Should be true if the connection is being creatd by a server, false otherwise\r\n        // sendCommandErrorInfo\r\n        // maxSendSize\r\n        // maxReceiveSize\r\n    this.init = function(rpepCoreObject, connectionObject, rpepOptions) {\r\n        this.transport = rpepCoreObject.transport\r\n        this.serialization = rpepCoreObject.serialization\r\n        this.commands = rpepCoreObject.commands\r\n\r\n        this.maxSendSize = rpepCoreObject.rpepOptions.maxSendSize\r\n        this.maxReceiveSize = rpepCoreObject.rpepOptions.maxReceiveSize\r\n        this.sendCommandErrorInfo = rpepCoreObject.rpepOptions.sendCommandErrorInfo\r\n        this.server = rpepOptions.server\r\n\r\n        this.connection = connectionObject\r\n        this.connected = true\r\n        this.sessionData = {}\r\n        this.commandState = {}\r\n        \r\n        if(this.server)\r\n            this.nextId = 0\r\n        else\r\n            this.nextId = 1\r\n\r\n        var that = this\r\n\r\n        if(this.connection.onClose) {\r\n            this.connection.onClose(function() {\r\n                that.connected = false\r\n                that.emit('close')\r\n            })\r\n        } else {\r\n            this.on('closeMessage', function() {\r\n                that.connected = false\r\n                that.emit('close')\r\n            })\r\n        }\r\n\r\n        this.connection.onMessage(function(rawMessage) {\r\n            handle(that, rawMessage)\r\n            that.emit('rawMessage', rawMessage)\r\n        })\r\n        this.connection.onError(function(e) {\r\n            that.emit('error', e)\r\n        })\r\n    }\r\n\r\n    // closes the connection\r\n    this.close = function() {\r\n        if(this.connected) {\r\n            if(this.connection.onClose === undefined) {\r\n                send(that, ['close'])\r\n            }\r\n\r\n            this.connection.close()\r\n            this.connection = undefined\r\n        }\r\n    }\r\n    // drops the connection without informing the other Peer if supported, otherwise with informing the other Peer\r\n    this.drop = function() {\r\n        if(this.connected && this.connection.drop) {\r\n            this.connection.drop()\r\n        } else {\r\n            this.close()\r\n        }\r\n    }\r\n\r\n    // fire and forget message\r\n    this.fire = function(command, data) {\r\n        if(command in reservedSendingCommands) {\r\n            throw new Error(\"Can't fire an '\"+command+\"' event directly; '\"+command+\"' is a global command reserved for internal use.\")\r\n        }\r\n\r\n        send(this, [command, data])\r\n    }\r\n    // fire and forget error\r\n    // The error must contain a message property. Any other iterable properties will be added as data.\r\n    this.fireError = function(error) {\r\n        send(this, ['e', [error, data]])\r\n    }\r\n\r\n    // request response\r\n    this.request = function(command, data) {\r\n        if(command in reservedSendingCommands) {\r\n            throw new Error(\"Can't fire an '\"+command+\"' event directly; '\"+command+\"' is a global command reserved for internal use.\")\r\n        }\r\n        if(this.commandState[this.nextId] !== undefined)\r\n            throw new Error('There is already a callback for id: '+this.nextId)\r\n\r\n        send(this, [command, this.nextId, data])\r\n\r\n        var resolver = resolver()\r\n        this.requestFutures[this.nextId] = resolver\r\n\r\n        incrementId(this)\r\n\r\n        return resolver.f\r\n    }\r\n\r\n    // full-duplex event stream\r\n    this.streamConnect = function(command, data) {\r\n        if(command in reservedSendingCommands) {\r\n            throw new Error(\"Can't fire an '\"+command+\"' event directly; '\"+command+\"' is a global command reserved for internal use.\")\r\n        }\r\n        if(this.commandState[this.nextId] !== undefined)\r\n            throw new Error('There is already a callback for id: '+this.nextId)\r\n\r\n        send(this, [command, this.nextId, data])\r\n        var emitter = createStreamEmiter(this, this.nextId)\r\n\r\n        incrementId(this)\r\n\r\n        return emitter\r\n    }\r\n\r\n    // private\r\n\r\n    function serialize(that,data) {\r\n        return that.serialization.serialize(data)\r\n    }\r\n    function deserialize(that,serializedData) {\r\n        return that.serialization.deserialize(serializedData)\r\n    }\r\n\r\n    // may send an idDiscontinuity message\r\n    function incrementId(that) {\r\n        var prevId = that.nextId\r\n        do {\r\n            that.nextId += 2\r\n            if(that.nextId > maxId) {\r\n                that.nextId = that.nextId%2 // reset to 0 or 1\r\n            }\r\n        } while(that.nextId in that.commandState)\r\n\r\n        if(that.nextId !== prevId+2) {\r\n            send(that, ['idDiscontinuity', [prevId,that.nextid]])\r\n        }\r\n    }\r\n\r\n    // may send an disctontinuity message\r\n    function incrementOrderNumber(emitter) {\r\n        emitter.orderNumber += 1\r\n        if(emitter.orderNumber > maxId) {\r\n            var prevNumber = emitter.orderNumber-1\r\n            emitter.orderNumber = 0\r\n            emitter.emit()\r\n            send(that, [emitter.id, 'orderNumberDiscontinuity', [prevNumber, that.orderNumber]])\r\n        }\r\n    }\r\n\r\n    // error is expected to be an exception object (with a message property at least)\r\n    function createErrorInfo(error) {\r\n        var data = {}, any = false\r\n        for(var k in error) {\r\n            if(k !== 'message') {\r\n                data[k] = error[k]\r\n                any = true\r\n            }\r\n        }\r\n\r\n        var errorInfo = [error.message]\r\n        if(any) {\r\n            errorInfo.push(data)\r\n        }\r\n\r\n        return errorInfo\r\n    }\r\n\r\n    function createErrorFromMessage(errorMessage, errorData) {\r\n        var e = new Error(errorMessage)\r\n        for(var k in errorData) {\r\n            if(k !== 'message')\r\n                e[k] = errorData[k]\r\n        }\r\n\r\n        return e\r\n    }\r\n\r\n    function createStreamEmiter(that, id) {\r\n        var emitter = RpepDuplexEventEmitter(function onEmit(event, data) {\r\n            if(emitter.endMessageSent)\r\n                throw new Error(\"Stream 'end' event has been sent, can't send more events.\")\r\n\r\n            if(event === 'error') {\r\n                if(emitter.orderingData) {\r\n                    send(that, [id,'e',createErrorInfo(data)])\r\n                    incrementOrderNumber(emitter)\r\n                } else {\r\n                    send(that, [id,'e',createErrorInfo(data)])\r\n                }\r\n            } else if(event in reservedStreamEmissionEvents) {\r\n                throw new Error(\"Can't emit the '\"+event+\"' event directly; '\"+event+\"' is reserved for internal use.\")\r\n            } else {\r\n                send(that, [id,event,createErrorInfo(data)])\r\n                if(event === 'end') {\r\n                    emitter.endMessageSent = true\r\n                    if(emitter.endMessageReceived) {\r\n                        delete that.commandState[id] // ensures that \"rpepIdNotFound\" will be returned if this stream continues to be communicated on\r\n                    }\r\n                }\r\n            }\r\n        })\r\n\r\n        emitter.id = id\r\n        emitter.orderingData = false\r\n        emitter.orderNumber = 0\r\n        emitter.endMessageSent = false\r\n        return emitter\r\n    }\r\n\r\n    // raw send\r\n    function send(that, message) {\r\n        var serializedMessage = serialize(that, message)\r\n        if(that.maxSendSize !== undefined && serializedMessage.length > that.maxSendSize) {\r\n            var e = new Error('maxMessageSizeExceeded')\r\n            e.messageSize = serializedMessage.length\r\n            throw e\r\n        }\r\n\r\n        if(this.connected) {\r\n            this.connection.send(serializedMessage)\r\n        } else {\r\n            throw Error('Connection is closed')\r\n        }\r\n    }\r\n\r\n    function handle(that, rawMessage) {\r\n        try {\r\n            if(that.rawHandler) {\r\n                if(that.rawHandler.call(that, rawMessage) === 'ignore') {\r\n                    return\r\n                }\r\n            }\r\n\r\n            try {\r\n                var message = deserialize(that, rawMessage)\r\n            } catch(e) {\r\n                if(that.sendCommandErrorInfo) {\r\n                    try {\r\n                        that.fireError(\"unparsableCommand\", {message: rawMessage})\r\n                    } catch(e) {\r\n                        if(e.message === 'maxMessageSizeExceeded')\r\n                            that.fireError(\"unparsableCommand\", {message: rawMessage.slice(0,200)})\r\n                        else throw e\r\n                    }\r\n                }\r\n\r\n                return\r\n            }\r\n\r\n            if(that.preHandler) {\r\n                if(that.preHandler.call(that, message) === 'ignore') {\r\n                    return\r\n                }\r\n            }\r\n\r\n            var type0 = typeof(message[0])\r\n            if(type0 === 'string') {\r\n                // open and close fire-and-forget connection establishment message\r\n                if(message.lengh === 0 && type0 === 'close') {\r\n                    that.emit(\"closeMessage\")\r\n                    return\r\n                }\r\n\r\n                var commandInfo = that.commands[command]\r\n                if(commandInfo === undefined) {\r\n                    that.fireError(\"noSuchCommand\", {command: message[1]})\r\n                    return\r\n                }\r\n\r\n                if(commandInfo.type === receive) {\r\n                    commandInfo.handler.call(that, message[1])\r\n                } else if(commandInfo.type === respond) {\r\n                    var id = message[1]\r\n                    if(!validateId(this, id)) {\r\n                        return\r\n                    }\r\n\r\n                    Promise.resolve().then(function() {\r\n                        return commandInfo.handler.call(that, message[2], id)\r\n                    }).then(function(result) {\r\n                        send(that, [id,result])\r\n                    }).catch(function(e) {\r\n                        if(e instanceof PeerError) {\r\n                            send(that, [id,'e',createErrorInfo(e)])\r\n                        } else {\r\n                            that.emit('error', e)\r\n                            send(that, [id,'e',createErrorInfo({message:'serverError'})])\r\n                        }\r\n                    })\r\n                } else if(commandInfo.type === stream) {\r\n                    var id = message[1]\r\n                    if(!validateId(this, id)) {\r\n                        return\r\n                    }\r\n                    \r\n                    var emitter = connection.commandState[id] = createStreamEmiter(that,id)\r\n\r\n                    Promise.resolve().then(function() {\r\n                        commandInfo.handler.call(that, emitter, message[2], id)\r\n                    }).catch(function(e) {\r\n                        that.emit('error', e) // note that PeerError objects are treated like normal Errors here - to emit an error, you must emit an 'error' event from the passed emitter\r\n                    })\r\n                } else {\r\n                    throw new Error(\"Invalid command type: \"+commandInfo.type)\r\n                }\r\n\r\n            } else if(type0 === 'number') {\r\n                if(!(type0 in that.commandState)) {\r\n                    that.fireError(\"rpepIdNotFound\", {id: type0})\r\n                    return\r\n                }\r\n\r\n                if(that.commandState[type0] instanceof RpepDuplexEventEmitter) { //stream\r\n                    var emitter = that.commandState[type0]\r\n                    if(emitter.orderingData) {\r\n                        var orderNumber = message[1], event = message[2], eventData = message[3]\r\n                    } else {\r\n                        var event = message[1], eventData = message[2]\r\n                    }\r\n\r\n                    if(event === 'order') {\r\n                        emitter.orderingData = eventData !== true\r\n                    } else {\r\n                        if(event === 'e') {\r\n                            var error = createErrorFromMessage(eventData[0], eventData[1])\r\n                            emitter._external.emit('error', error, orderNumber)\r\n                        } else {\r\n                            emitter._external.emit(event, eventData, orderNumber)\r\n\r\n                            if(event === 'end') {\r\n                                emitter.endMessageReceived = true\r\n                                if(emitter.endMessageSent) {\r\n                                    delete that.commandState[type0] // ensures that \"rpepIdNotFound\" will be returned if this stream continues to be communicated on\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                } else { // response\r\n                    var theResolver = that.commandState[type0]\r\n                    if(message.length === 3) { // error response\r\n                        theResolver.reject(createErrorFromMessage(message[2][0], message[2][1]))\r\n                    } else { // normal response\r\n                        theResolver.resolve(message[1])\r\n                    }\r\n                }\r\n            } else {\r\n                if(that.sendCommandErrorInfo) {\r\n                    that.fireError(\"invalidMessage\", {message: rawMessage.slice(0,200)})\r\n                } else {\r\n                    that.fireError(\"invalidMessage\")\r\n                }\r\n            }\r\n        } catch(e) {\r\n            connection.emit('error', e)\r\n        }\r\n    }\r\n})\r\n\r\n// sends an rpepInvalidId error fire-and-forget message if the id isn't valid\r\n// returns true if the id is valid, false otherwise\r\nfunction validateId(that, id) {\r\n    if(id > maxId) {\r\n        var reason = \"Id greater than 2^53\"\r\n    } else if(that.server) {\r\n        if(id%2 !== 1) {\r\n            var reason = \"Id from client not odd\"\r\n        }\r\n    } else if(id%2 !== 0) {\r\n        var reason = \"Id from server not even\"\r\n    }\r\n\r\n    if(reason !== undefined) {\r\n        that.fireError('rpepInvalidId', {reason: reason})\r\n    }\r\n}\r\n\r\nfunction resolver() {\r\n    var resolve, reject\r\n    var f = new Promise(function(inResolve, inReject) {\r\n        resolve = inResolve\r\n        reject = inReject\r\n    })\r\n\r\n    return {f: f, resolve:resolve, reject:reject}\r\n}\r\n\r\n\r\nvar RpepDuplexEventEmitter = proto(DuplexEventEmitter, function(superclass) {\r\n    this.on = function(event,handler) {\r\n        if(event in reservedEventListeningEvents)\r\n            throw new Error(\"Can't listen on the '\"+event+\"' event directly; the '\"+event+\"' event is reserved for internal use.\")\r\n\r\n        superclass.on.call(this, event,handler)\r\n    }\r\n})\n\n\n// WEBPACK FOOTER //\n// ./rpep.js(original)","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/process/browser.js\n// module id = 3\n// module chunks = 0","var proto = require(\"proto\")\nvar EventEmitter = require('eventemitter2')\n\n// an event emitter where listening to it listens to the other end and emitting emits to the other end\nmodule.exports = proto(function() {\n    this.init = function(onEmitHandler) {\n        this._external = new EventEmitter\n        this._onEmitHandler = onEmitHandler\n    }\n\n    this.emit = function(event, data) {\n        if(this.ended) throw new Error(\"Duplex Stream has already been ended.\")\n        this._onEmitHandler(event,data)\n    }\n    this.on = function(event,handler) {\n        this._external.on(event,handler)\n    }\n    this.off = this.removeListener = function(event, handler) {\n        this._external.removeListener(event,handler)\n    }\n    this.onAny = function(handler) {\n        this._external.onAny(handler)\n    }\n\n    this.end = function() {\n        this.emit('end')\n        this.ended = true\n    }\n})\n\n\n// WEBPACK FOOTER //\n// ./DuplexEventEmitter.js(original)"],"sourceRoot":""}