var utils = require("../../utils")
var seq = require("testUtils").seq
var rpep = require('../../rpep')

// options
    // clientOptions - options to pass into each client.connect in the test
    // rawMessages - An array of 3 elements, where each element is an array with two elements:
        // the first element of each is the string message
        // the second element of each is a function that's passed the resulting raw message, and should return true if it matches what's expected based on the first element
module.exports = function(getTestTransport, testSerialization, options) {
    var lastOptions;
    var nextOptions = function() {
        lastOptions = options.nextClientOptions(lastOptions)
        return lastOptions
    }

    return function() {



        //*

        this.test("connect and close", function() {
            this.test('basic successful connection, closed on connecting end', function(t) {
                this.count(2)

                var client = rpep(getTestTransport(), testSerialization)
                client.connect.apply(client, nextOptions()).then(function(conn) {
                    t.ok(true)
                    conn.on('close', function() {
                        t.ok(true)
                    })
                    conn.close()
                })
            })
            this.test('basic successful connection, closed on listening end', function(t) {
                this.count(2)

                var client = rpep(getTestTransport(), testSerialization)
                client.connect.apply(client, nextOptions()).then(function(conn) {
                    t.ok(true)
                    conn.on('close', function() {
                        t.ok(true)
                    })
                })
            })
            this.test('basic connection error(s)', function(t) {
                this.count(1)

                var client = rpep(getTestTransport(), testSerialization)
                client.connect.apply(client, options.clientErrorOptions).catch(function(e) {
                    t.eq(e.message, options.clientError)
                })
            })
        })

        this.test("listen and close", function() {
            this.test('basic listen, closed on listening end', function(t) {
                var client = rpep(getTestTransport(), testSerialization)
                client.connect.apply(client, nextOptions())
            })
            this.test('basic listen, closed on connecting end', function(t) {
                var client = rpep(getTestTransport(), testSerialization)
                client.connect.apply(client, nextOptions()).then(function(conn) {
                    conn.close()
                })
            })
            this.test('basic listen, rejection', function(t) {
                this.count(1)

                var client = rpep(getTestTransport(), testSerialization)
                client.connect.apply(client, nextOptions()).then(function() {
                    // t.ok(false)
                }).catch(function(e) {
                    t.ok(e.message.indexOf("Connection couldn\'t be opened") !== -1, e.message)
                })
            })
            this.test('basic listen error', function(t) {
                // no test needed on client end
            })
        })

        this.test("fire and receive", function(t) {
            this.count(9)

            var event = seq(function(eventName, req) {
                t.eq(eventName,'c')
                t.eq(req,undefined)
            },function(eventName, a, b) {
                t.eq(eventName,'d')
                t.eq(a,3)
                t.eq(b,4)
            },function(eventName, e) {
                t.eq(eventName,'client error')
                t.ok(e instanceof Error)
                t.eq(e.message, 'error from server')
            })

            var client = rpep(getTestTransport(), testSerialization)
            client.receive('c', function(req) {
                event('c', req)
                this.fire('a')

            })
            client.receive('d', function(a, b) {
                event('d', a, b)
                this.fire('b', 5)
            })
            client.receive('error', function(e) {
                event('client error', e)

                var error = new Error("error from client")
                error.someData = 'client data'
                this.fire('error', error)
            })

            client.connect.apply(client, nextOptions()).then(function(conn) {
                t.ok(true)
            })
        })

        this.test("send/receive", function(t) {
            this.test("basic send/receive", function(t) {
                this.count(19)

                var event = seq(function(eventName, result) {
                    t.eq(eventName,'a result')
                    t.eq(result,1)
                },function(eventName, e) {
                    t.eq(eventName,'b error')
                    t.ok(e instanceof Error)
                    t.eq(e.message, "b error")
                },function(eventName, one,two,id) {
                    t.eq(eventName,'d')
                    t.eq(one,'yo')
                    t.eq(two,'boy')
                    t.eq(id,0)
                },function(eventName, id) {
                    t.eq(eventName,'e')
                    t.eq(id, 2)
                },function(eventName, id) {
                    t.eq(eventName,'f')
                    t.eq(id, 4)
                },function(eventName, e) {
                    t.eq(eventName,'client error')
                    t.ok(e instanceof Error)
                    t.eq(e.message, "f error")
                },function(eventName, e) {
                    t.eq(eventName,'c error')
                    t.ok(e instanceof Error)
                    t.eq(e.message, "unexpectedPeerError")
                })


                var client = rpep(getTestTransport(), testSerialization)
                client.respond('d', function(one,two, id) {   // return promise value
                    event('d', one,two,id)
                    return new Promise(function(resolve) {
                        resolve(3)
                    })
                })
                client.respond('e', function(id) {   // return normal error
                    event('e', id)

                    throw new rpep.PeerError("e error")
                })
                client.respond('f', function(req) {   // fail on thrown error (non-PeerError)
                    event('f', req)

                    throw new Error("f error")
                })

                client.connect.apply(client, nextOptions()).then(function(conn) {
                    conn.on('error', function(e) {
                        event('client error', e)
                    })

                    return conn.request("a").then(function(result) {
                        event('a result', result)
                        return conn.request('b', "hi")
                    }).catch(function(e) {
                        event('b error', e)
                        return conn.request('c', 99, 'bwak')
                    }).catch(function(e) {
                        event('c error', e)
                    })
                })
            })

            this.test("multiple outstanding calls to the same request", function(t) {
                this.count(2)

                var client = rpep(getTestTransport(), testSerialization)

                client.connect.apply(client, nextOptions()).then(function(conn) {
                    var one = conn.request("a")
                    var two = conn.request("a")

                    one.then(function(n) {
                        t.eq(n,0)
                    })
                    two.then(function(n) {
                        t.eq(n,1)
                    })

                    conn.fire('b')
                })
            })

            this.test('id discontinuity', function(t) {
                var client = rpep(getTestTransport(), testSerialization, {maxId: 4})
                client.connect.apply(client, nextOptions()).then(function(conn) {
                    return conn.request('a').then(function() {
                        return conn.request('a')
                    }).then(function() {
                        return conn.request('a')
                    })
                })
            })
        })

        this.test("event streams", function(t) {
            this.test('basic event streams', function(t) {
                this.count(24)

                var event = seq(function(eventName, args) {
                    t.eq(eventName,'client one')
                    t.eq(args.length,0)
                },function(eventName, args) {
                    t.eq(eventName,'client two')
                    t.eq(args[0], 2)
                },function(eventName, args) {
                    t.eq(eventName,'client three')
                    t.eq(args[0], 3)
                    t.eq(args[1], 4)
                },function(eventName, args) {
                    t.eq(eventName,'client error')
                    t.eq(args[0].message, 'wut up')
                },function(eventName) {
                    t.eq(eventName,'client end')
                },function(eventName, one, two, id) {        // server-started event-stream
                    t.eq(eventName,'client b')
                    t.eq(one,'one')
                    t.eq(two,'two')
                    t.eq(id,0)
                },function(eventName, x,y) {
                    t.eq(eventName,'client two2')
                    t.eq(x,'x')
                    t.eq(y,'y')
                },function(eventName) {
                    t.eq(eventName,'client sendError2')
                },function(eventName) {
                    t.eq(eventName,'client doError2')
                },function(eventName, e) {
                    t.eq(eventName,'client error')
                    t.eq(e.message, "oh noz")
                },function(eventName, a, b) {
                    t.eq(eventName,'client end2')
                    t.eq(a, 5)
                    t.eq(b, 6)
                })


                var client = rpep(getTestTransport(), testSerialization)
                client.stream('b', function(stream, one,two, id) {   // return promise value
                    event('client b', one,two,id)
                    stream.emit('one')

                    stream.on('two', function(a, b) {
                        event('client two2', a,b)
                        stream.emit('two', 2)
                        stream.emit('three', 3, 4)
                    })
                    stream.on('sendError', function() {
                        event('client sendError2')
                        stream.emit('error', new Error("whats up"))
                    })
                    stream.on('end', function(a, b) {
                        event('client end2', a, b)
                        stream.emit('end')
                    })
                    stream.on('doError', function() {
                        event('client doError2')
                        throw new Error("oh noz")
                    })
                })

                client.connect.apply(client, nextOptions()).then(function(conn) {
                    conn.on('error', function(e) {
                        event('client error', e)
                    })

                    var stream = conn.streamConnect('a')
                    stream.onAny(function(eventName, args) {
                        var args = Array.prototype.slice.call(arguments,1)
                        event('client '+eventName, args)

                        if(eventName === 'one') {
                            stream.emit('two', 'a','b')
                        } else if(eventName === 'two') {
                            // nothing
                        } else if(eventName === 'three') {
                            stream.emit('sendError')
                        } else if(eventName === 'error') {
                            stream.emit('sendEnd')
                        } else if(eventName === 'end') {
                            stream.emit('end')
                        }
                    })
                })
            })

            this.test("multiple outstanding streams of the same command", function(t) {
                this.count(4)

                var client = rpep(getTestTransport(), testSerialization)
                client.connect.apply(client, nextOptions()).then(function(conn) {
                    var stream1 = conn.streamConnect('a', 1)
                    var stream2 = conn.streamConnect('a', 2)

                    stream1.on('hi', function(x) {
                        t.eq(x,1)
                    })
                    stream1.on('end', function() {
                        t.ok(true)
                    })
                    stream2.on('hi', function(x) {
                        t.eq(x,2)
                    })
                    stream2.on('end', function() {
                        t.ok(true)
                    })

                    stream1.emit('x')
                    stream2.emit('x')

                    stream1.emit('end')
                    stream2.emit('end')
                })
            })

            this.test('event order numbers and order number discontinuity', function(t) {
                this.count(10)

                var client = rpep(getTestTransport(), testSerialization)
                client.connect.apply(client, nextOptions()).then(function(conn) {
                    var stream1 = conn.streamConnect('a', 1)

                    stream1.on('hi', function() {
                        if(arguments.length === 1) {
                            t.eq(arguments[0],0) // order number
                        } else if(arguments.length === 2) {
                            t.eq(arguments[0],'a')
                            t.eq(arguments[1],1) // order number
                        } else if(arguments.length === 3) {
                            t.eq(arguments[0],'b')
                            t.eq(arguments[1],'c')
                            t.eq(arguments[2],2) // order number
                        }
                    })
                    stream1.on('orderNumberDiscontinuity', function(prevId, nextId, orderNumber) {
                        t.eq(prevId, 2)
                        t.eq(nextId, 0)
                        t.eq(orderNumber, 0)
                    })
                    stream1.on('end', function() {
                        t.ok(true)
                    })

                    stream1.emit('order', true)
                    stream1.emit('x')
                    stream1.emit('x', 'a')
                    stream1.emit('x', 'b', 'c')

                    stream1.emit('end')
                })
            })
        })

        this.test('sessionData', function(t) {
            var client = rpep(getTestTransport(), testSerialization)
            client.connect.apply(client, nextOptions()).then(function(conn) {
                conn.fire('a')
                conn.request('b').then(function() {
                    var s = conn.streamConnect('c')
                    s.on('end', function() {
                        s.emit('end')
                        conn.fire('d')
                    })
                })
            })
        })

        this.test("rawHandle, preHandle, and default", function(t) {
            var client = rpep(getTestTransport(), testSerialization)
            client.connect.apply(client, nextOptions()).then(function(conn) {
                conn.fire(options.rawMessages[0].message)
                conn.fire(options.rawMessages[1].message)
                conn.fire(options.rawMessages[2].message)
            })
        })
        //
        this.test('default error handlers', function() {
            this.test("no 'error' receive handler", function(t) {
                var client = rpep(getTestTransport(), testSerialization)
                client.connect.apply(client, nextOptions()).then(function(conn) {
                    conn.fire('error', new Error("unhandled error"))
                })
            })
            this.test("no 'error' event handler", function(t) {
                var client = rpep(getTestTransport(), testSerialization)
                client.connect.apply(client, nextOptions()).then(function(conn) {
                    var s = conn.streamConnect('a')
                    s.emit('error', new Error("unhandled error"))
                })
            })
        })

        if(options.clientNoOnClose) {
            this.test("close messages for transports that don't have onClose handlers", function(t) {
                var testTransportCopy = {}, testTransport = getTestTransport()
                for(var k in getTestTransport()) {
                    testTransportCopy[k] = testTransport[k]
                }
                delete testTransportCopy.onClose

                var client = rpep(testTransportCopy, testSerialization)
                client.preHandle(function(c) {
                    t.ok(false) // shouldn't get called
                })
                client.connect.apply(client, options.clientNoOnClose).then(function(conn) {
                    conn.close()
                })
            })
        }

        this.test('errors', function(t) {
            this.test("basic errors", function(t) {
                this.count(9)

                var client = rpep(getTestTransport(), testSerialization), send
                client.connect.apply(client,nextOptions()).then(function(conn) {
                    var event = seq(function(eventName,e) {
                        t.eq(eventName, 'error')
                        t.eq(e.message, 'noSuchCommand')
                        t.eq(e.command, 'nonexistent')
                    },function(eventName,e) {
                        t.eq(eventName, 'error')
                        t.eq(e.message, 'noSuchCommand')
                        t.eq(e.command, 'nonexistent')
                    },function(eventName,e) {
                        t.eq(eventName, 'error')
                        t.eq(e.message, 'noSuchCommand')
                        t.eq(e.command, 'nonexistent')
                    })

                    conn.on('error', function(e) {
                        event('error',e)
                    })

                    conn.fire('nonexistent')
                    conn.request('nonexistent').then(function() {
                        t.ok(false) // won't get here
                    }).catch(function(e) {
                        t.ok(false) // won't get here
                    })
                    var stream = conn.streamConnect('nonexistent')
                    stream.on('error', function() {
                        t.ok(false) // won't get here
                    })
                })
            })

            if(options.clientWithRawMessageSend) {
                this.test("invalidId error", function(t) {
                    this.count(2)

                    var client = rpep(getTestTransport(), testSerialization)
                    client.connect.apply(client, options.clientWithRawMessageSend).then(function(conn) {
                        conn.on('error', function(e) {
                            t.eq(e.message, 'rpepInvalidId')
                            t.eq(e.reason, 'Id from client not odd')
                        })

                        // should produce invalidId
                        options.clientSend(testSerialization.serialize(['a',46]))
                    })
                })
            }

            this.test("ensure no events can be emitted after sending 'end'", function(t) {
                this.count(1)

                var client = rpep(getTestTransport(), testSerialization)
                client.connect.apply(client, nextOptions()).then(function(conn) {
                    var stream = conn.streamConnect('a')
                    stream.emit('end')
                    try {
                        stream.emit('somethingElse')
                    } catch(e) {
                        t.eq(e.message, "Stream 'end' event has been sent, can't send more events.")
                    }
                })
            })

            if(options.listenerWithRawMessageSend) {
                this.test("ensure no events can be received after receiving and sending 'end'", function(t) {
                    this.count(1)

                    var client = rpep(getTestTransport(), testSerialization)
                    client.connect.apply(client, options.listenerWithRawMessageSendClient).then(function(conn) {
                        var stream = conn.streamConnect('a')
                        stream.emit('end')
                        stream.onAny(function(eventName) {
                            t.eq(eventName, 'end')
                        })
                    })
                })
            }

            this.test("closeTimeout", function(t) {
                this.count(1)

                var client = rpep(getTestTransport(), testSerialization, {closeTimeout:500})
                client.respond('x', function() {
                    return utils.resolver().f // will never resolve
                })
                client.connect.apply(client, nextOptions()).then(function(conn) {
                    conn.request('a')
                    var stream1 = conn.streamConnect('b')
                    var stream2 = conn.streamConnect('c')
                    var stream3 = conn.streamConnect('b')

                    stream1.emit('end')

                    conn.on('error', function(e) {
                        t.log(e.message)
                        t.eq(e.message, "Connection has been closed after a 500ms timeout and some pending requests and streams remain unfulfilled. "+
                                        "The following requests and streams were still active up until the timeout:\n"+
                                        "* Response 0 for 'x'\n"+
                                        "* Request 1 to 'a'\n"+
                                        "* Stream 3 'b' waiting for other side to 'end'\n"+
                                        "* Stream 5 'c' has received 'end' but hasn't sent 'end'\n"+
                                        "* Stream 7 'b' is still active"
                        )
                    })

                    conn.close()
                })
            })
        })

        //*/
    }

}